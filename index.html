<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Added user-scalable=no -->
    <title>Pixel Farm Game</title>
    <style>
        body {
            font-family: 'Consolas', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            color: white;
            overflow: hidden;
            touch-action: none; /* Prevent default touch actions like scroll/zoom */
        }

        h1 {
            margin-bottom: 15px;
            font-weight: normal;
        }

        p {
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
            text-align: center; /* Center instructions */
        }

        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;

            background-color: #000;
            border: 2px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(150, 150, 255, 0.5),
                        inset 0 0 10px rgba(0, 0, 0, 0.5);
            padding: 2px;
            overflow: hidden;
        }

        canvas, #nightOverlay, #lightCanvas {
            position: absolute;
            top: 2px;
            left: 2px;
            image-rendering: pixelated;
            width: calc(100% - 4px);
            height: calc(100% - 4px);
            border-radius: 8px;
        }

        #gameContainer > #itemTooltip { position: absolute; } /* Override if needed */

        #nightOverlay {
            background-color: #000033;
            opacity: 0;
            z-index: 5;
            pointer-events: none;
            transition: opacity 1s linear;
        }

        #lightCanvas {
            z-index: 6;
            pointer-events: none;
        }

        /* --- Container da Hotbar e √çcone da Mochila --- */
        #bottomUIContainer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: flex-end; /* Alinha o √≠cone e a hotbar na base */
            gap: 8px; /* Espa√ßo entre o √≠cone e a hotbar */
            z-index: 10;
        }

        /* √çcone da Mochila */
        #backpackIcon {
            width: 45px;
            height: 45px;
            background-color: rgba(68, 68, 68, 0.8); /* #444 com alpha */
            border: 2px solid #888;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px; /* Tamanho do emoji */
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
        }
        #backpackIcon:hover {
            background-color: rgba(102, 102, 102, 0.9); /* #666 com alpha */
            border-color: #aaa;
        }


        /* Barra de Atalhos (Hotbar) */
        #hotbar {
            /* position, bottom, left, transform removidos (agora controlados pelo container) */
            display: flex;
            gap: 3px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            padding: 5px;
            border-radius: 8px;
            /* z-index removido (controlado pelo container) */
        }

        /* --- Estilo Geral do Slot (usado por Hotbar e Mochila) --- */
        .slot {
            width: 45px;
            height: 45px;
            border: 2px solid #888;
            background-color: #444;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: white;
            position: relative;
            cursor: pointer;
            user-select: none;
             transition: transform 0.1s ease-out, opacity 0.1s ease-out; /* Para feedback visual ao arrastar */
        }
        /* Estilo para quando um slot est√° sendo arrastado */
        .slot.dragging {
            opacity: 0.5;
            transform: scale(0.9);
        }
        /* Estilo para quando o mouse est√° sobre um slot v√°lido para soltar */
        .slot.drag-over {
            border-color: #FFD700; /* Dourado */
            background-color: #555;
        }


        /* Destaque do slot ativo na hotbar */
        #hotbar .slot.active {
            background-color: #666;
            border-color: #FFF;
            box-shadow: 0 0 8px #FFF;
        }

        /* --- Container da Mochila --- */
        #backpackContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(40, 40, 40, 0.95); /* Slightly less transparent */
            border: 3px solid #666;
            border-radius: 10px;
            padding: 15px;
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        #backpackTitle {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #eee;
        }

        #backpackGrid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 8px;
        }

        #backpackGrid .slot {
             width: 50px;
             height: 50px;
             font-size: 10px;
        }

        #backpackGrid .slot.selected-for-assignment {
             border-color: #FFD700;
             box-shadow: 0 0 8px #FFD700;
         }

        .slot-name {
            font-weight: bold;
            font-size: 10px;
            text-shadow: 1px 1px #000;
            pointer-events: none;
        }

        .slot-count {
            margin-top: 2px;
            font-size: 12px;
            color: #FFD700;
            font-weight: bold;
            pointer-events: none;
        }

        #hotbar .slot-key {
            position: absolute;
            top: 1px;
            left: 2px;
            font-size: 9px;
            color: #AAA;
            font-weight: bold;
            pointer-events: none;
        }

        #gameClock {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            padding: 5px 10px 5px 30px;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px #000;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .time-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: transparent;
            flex-shrink: 0;
        }

        #gameClock span {
            line-height: 1;
        }

        /* --- Container do Slider de Tempo --- */
        #timeControlContainer {
            display: flex;
            align-items: center;
            gap: 10px;
             margin-top: 5px;
        }

        #timeControlContainer label {
            font-size: 0.9em;
        }

        #timeRangeSlider {
            width: 150px;
            cursor: pointer;
        }

        /* Estilos para o bot√£o antigo, podem ser removidos ou adaptados */
        #timeToggleButton:hover { /* Mantido caso queira reutilizar o ID */
             background-color: #777;
        }

        /* --- Tooltip de Descri√ß√£o do Item --- */
        #itemTooltip {
            position: absolute; /* Posi√ß√£o relativa ao gameContainer */
            display: none;   /* Come√ßa escondido */
            background-color: rgba(20, 20, 20, 0.9);
            border: 1px solid #999;
            border-radius: 5px;
            padding: 8px 12px;
            color: #E0E0E0;
            font-size: 0.9em;
            max-width: 220px;
            z-index: 100; /* Fica em cima de tudo */
            pointer-events: none; /* Impede que o tooltip intercepte eventos do mouse */
            text-align: left;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.6);
        }

    </style>
</head>
<body>
    <h1>Mini Fazenda Pixelada</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas">
            Seu navegador n√£o suporta o elemento Canvas.
        </canvas>

        <div id="itemTooltip"></div>

        <div id="nightOverlay"></div>
        <canvas id="lightCanvas"></canvas>
        <div id="gameClock">
            <canvas id="timeIconCanvas" class="time-icon" width="20" height="20"></canvas>
            <span>00:00</span>
        </div>

        <div id="backpackContainer">
            <div id="backpackTitle">Mochila</div>
            <div id="backpackGrid">
                <!-- Slots da mochila gerados pelo JS -->
            </div>
             <p style="font-size: 0.8em; margin-top: 10px; color: #ccc;">Clique em um item e depois em um atalho (1-0) para atribuir.</p>
        </div>

        <div id="bottomUIContainer">
            <div id="backpackIcon">üéí</div>
            <div id="hotbar">
                <div class="slot" data-hotbar-index="0" draggable="true"> <span class="slot-key">1</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="1" draggable="true"> <span class="slot-key">2</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="2" draggable="true"> <span class="slot-key">3</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="3" draggable="true"> <span class="slot-key">4</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="4" draggable="true"> <span class="slot-key">5</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="5" draggable="true"> <span class="slot-key">6</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="6" draggable="true"> <span class="slot-key">7</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="7" draggable="true"> <span class="slot-key">8</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="8" draggable="true"> <span class="slot-key">9</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="9" draggable="true"> <span class="slot-key">0</span> <span class="slot-name"></span> <span class="slot-count"></span> </div>
            </div>
        </div>


    </div>
    <!-- Instru√ß√µes Atualizadas -->
    <p>Setas/Toque: Mover. Espa√ßo/Toque √† frente: Usar. 1-0: Atalhos. B/üéí: Mochila.</p>
    <!-- Controle de Tempo Atualizado -->
    <div id="timeControlContainer">
        <label for="timeRangeSlider">Hora (Teste):</label>
        <input type="range" id="timeRangeSlider" min="0" max="23" step="1" value="0">
    </div>

    <script>
        // --- Configura√ß√µes Iniciais ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameClockSpan = document.querySelector('#gameClock span');
        const timeIconCanvas = document.getElementById('timeIconCanvas');
        const timeIconCtx = timeIconCanvas.getContext('2d');
        const nightOverlay = document.getElementById('nightOverlay');
        const lightCanvas = document.getElementById('lightCanvas');
        const lightCtx = lightCanvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const backpackContainer = document.getElementById('backpackContainer');
        const backpackGrid = document.getElementById('backpackGrid');
        const hotbarElement = document.getElementById('hotbar');
        let backpackIcon = null; // Definido dentro de init()
        let timeRangeSlider = null; // Definido dentro de init()
        let itemTooltip = null; // Definido dentro de init()

        ctx.imageSmoothingEnabled = false;
        timeIconCtx.imageSmoothingEnabled = false;
        lightCtx.imageSmoothingEnabled = false;

        const zoomLevel = 1;

        canvas.width = (640 - 4) / zoomLevel;
        canvas.height = (480 - 4) / zoomLevel;
        lightCanvas.width = canvas.width;
        lightCanvas.height = canvas.height;

        // --- Configura√ß√µes do Jogo ---
        const TILE_SIZE = 32;
        const GROWTH_TIME_SPROUT = 60000;
        const GROWTH_TIME_PLANT = 120000;
        const GROWTH_TIME_HARVEST = 180000;
        const TOOL_ANIM_DURATION = 150;
        const BACKPACK_SIZE = 20;
        const HOTBAR_SIZE = 10;
        const TOUCH_MOVE_THRESHOLD = TILE_SIZE * 0.5; // Dist√¢ncia m√≠nima para registrar toque como movimento
        const TAP_TIME_THRESHOLD = 300; // Tempo m√°ximo (ms) para um toque ser considerado 'tap' para a√ß√£o (aumentado um pouco)

        // --- Estado do Jogo ---
        let player = {
            x: 11 * TILE_SIZE, y: 11 * TILE_SIZE, width: 20, height: 28,
            colorHead: '#FFDAB9', colorBody: '#007BFF', colorLegs: '#0056B3',
            speed: 2, isMoving: false, targetX: 11 * TILE_SIZE, targetY: 11 * TILE_SIZE,
            walkBob: 0, walkBobSpeed: 0.15, isUsingTool: false, toolAnimStart: 0,
            lastMoveDir: { dx: 0, dy: 1 }
        };

        let camera = { x: 0, y: 0 };

        // --- Gera√ß√£o do Mapa ---
        const MAP_WIDTH_TILES = 50;
        const MAP_HEIGHT_TILES = 50;
        const BORDER_SIZE = 5;

        // 0=Grama, 1=Terra, 2=Arado, 3=√Ågua, 4=Semente, 5=Muda, 6=Planta, 7=Colheita
        // Layout do mapa original (para ser "colado" no mapa maior)
        const originalMapLayout = [
            [0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,3,3,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,3,3,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,3,3,0,0,0,0,0,1,2,1,1,2,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,3,3,0,3,0,0,1,2,1,1,2,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,3,3,3,3,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,3,3,3,3,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,3,3,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,3,3,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];
        const originalMapWidth = originalMapLayout[0].length;
        const originalMapHeight = originalMapLayout.length;

        // Calcula o deslocamento para centralizar o mapa antigo
        const mapOffsetX = Math.floor((MAP_WIDTH_TILES - originalMapWidth) / 2);
        const mapOffsetY = Math.floor((MAP_HEIGHT_TILES - originalMapHeight) / 2);

        let map = [];
        for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
            let row = [];
            for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                // Adiciona a borda de √°gua
                if (x < BORDER_SIZE || x >= MAP_WIDTH_TILES - BORDER_SIZE || y < BORDER_SIZE || y >= MAP_HEIGHT_TILES - BORDER_SIZE) {
                    row.push(3); // √Ågua
                } else {
                    // Verifica se estamos na √°rea do mapa antigo
                    const oldX = x - mapOffsetX;
                    const oldY = y - mapOffsetY;
                    if (oldY >= 0 && oldY < originalMapHeight && oldX >= 0 && oldX < originalMapWidth) {
                        row.push(originalMapLayout[oldY][oldX]);
                    } else {
                        row.push(0); // Grama para o resto
                    }
                }
            }
            map.push(row);
        }

        const MAP_WIDTH_PX = MAP_WIDTH_TILES * TILE_SIZE; const MAP_HEIGHT_PX = MAP_HEIGHT_TILES * TILE_SIZE;

        let plantGrowthData = {};

        // type: 0=Rocha, 1=√Årvore, 2=Fogueira, 3=Tocha
        // As coordenadas s√£o ajustadas com o offset para centralizar
        let mapObjects = [
            // √Årvores
            { type: 1, x: 4 + mapOffsetX, y: 7 + mapOffsetY }, { type: 1, x: 6 + mapOffsetX, y: 10 + mapOffsetY }, { type: 1, x: 18 + mapOffsetX, y: 8 + mapOffsetY }, { type: 1, x: 20 + mapOffsetX, y: 12 + mapOffsetY }, { type: 1, x: 22 + mapOffsetX, y: 5 + mapOffsetY },
            { type: 1, x: 2 + mapOffsetX, y: 15 + mapOffsetY }, { type: 1, x: 10 + mapOffsetX, y: 20 + mapOffsetY }, { type: 1, x: 15 + mapOffsetX, y: 25 + mapOffsetY }, { type: 1, x: 23 + mapOffsetX, y: 20 + mapOffsetY }, { type: 1, x: 5 + mapOffsetX, y: 22 + mapOffsetY },
            // Rochas
            { type: 0, x: 5 + mapOffsetX, y: 8 + mapOffsetY }, { type: 0, x: 19 + mapOffsetX, y: 6 + mapOffsetY }, { type: 0, x: 21 + mapOffsetX, y: 11 + mapOffsetY }, { type: 0, x: 23 + mapOffsetX, y: 14 + mapOffsetY }, { type: 0, x: 17 + mapOffsetX, y: 13 + mapOffsetY },
            { type: 0, x: 8 + mapOffsetX, y: 16 + mapOffsetY }, { type: 0, x: 12 + mapOffsetX, y: 22 + mapOffsetY }, { type: 0, x: 1 + mapOffsetX, y: 20 + mapOffsetY }, { type: 0, x: 16 + mapOffsetX, y: 18 + mapOffsetY }, { type: 0, x: 20 + mapOffsetX, y: 26 + mapOffsetY },
            // Fogueiras e Tochas
            { type: 2, x: 13 + mapOffsetX, y: 12 + mapOffsetY }, { type: 2, x: 8 + mapOffsetX, y: 18 + mapOffsetY },
            { type: 3, x: 16 + mapOffsetX, y: 1 + mapOffsetY }, { type: 3, x: 1 + mapOffsetX, y: 15 + mapOffsetY }, { type: 3, x: 23 + mapOffsetX, y: 1 + mapOffsetY }, { type: 3, x: 12 + mapOffsetX, y: 24 + mapOffsetY },
        ];

        // Adiciona as novas √°reas de recursos densos (tamb√©m com offset)
        // Floresta Densa (originalmente em x: 30-38, y: 5-15)
        for (let y = 5; y <= 15; y++) {
            for (let x = 30; x <= 38; x++) {
                mapObjects.push({ type: 1, x: x + mapOffsetX, y: y + mapOffsetY });
            }
        }

        // Campo de Rochas (originalmente em x: 5-15, y: 30-38)
        for (let y = 30; y <= 38; y++) {
            for (let x = 5; x <= 15; x++) {
                mapObjects.push({ type: 0, x: x + mapOffsetX, y: y + mapOffsetY });
            }
        }

        // --- Adiciona um cercadinho pr√©-constru√≠do perto da fazenda ---
        const fenceStartX = 20;
        const fenceStartY = 13;
        const fenceEndX = 27;
        const fenceEndY = 20;
        const gateX = 23; // Posi√ß√£o X do port√£o

        // Paredes superior e inferior (horizontais)
        for (let x = fenceStartX; x <= fenceEndX; x++) {
            mapObjects.push({ type: 4, x: x, y: fenceStartY, orientation: 'horizontal' });
            if (x < gateX || x > gateX + 1) { // Deixa um espa√ßo de 2 tiles para o port√£o
                mapObjects.push({ type: 4, x: x, y: fenceEndY, orientation: 'horizontal' });
            }
        }
        // Paredes laterais (verticais)
        for (let y = fenceStartY + 1; y < fenceEndY; y++) {
            mapObjects.push({ type: 4, x: fenceStartX, y: y, orientation: 'vertical' });
            mapObjects.push({ type: 4, x: fenceEndX, y: y, orientation: 'vertical' });
        }

        // --- Estrutura de Invent√°rio ---
        let backpackInventory = new Array(BACKPACK_SIZE).fill(null);
        let hotbarMapping = new Array(HOTBAR_SIZE).fill(-1);
        let activeHotbarSlot = 0;
        let isBackpackOpen = false;
        let selectedBackpackIndex = -1;

        let activeAnimations = [];

        // --- Vari√°veis de Tempo ---
        const itemDescriptions = {
            "Enxada": "<strong>Enxada</strong><br>Prepara a terra para o plantio em tiles de grama ou terra.",
            "Semente": "<strong>Semente</strong><br>Plante em solo arado para cultivar. A colheita pode render mais sementes.",
            "Colheita": "<strong>Colheita</strong><br>O fruto do seu trabalho. Um dia, talvez possa ser vendido.",
            "P√°": "<strong>P√°</strong><br>Remove planta√ß√µes, cercas e outros erros. Transforma grama em terra ou √°gua (perto de √°gua).",
            "Regador": "<strong>Regador</strong><br>Acelera o crescimento das plantas. Recarregue na √°gua.",
            "Martelo": "<strong>Martelo</strong><br>Constr√≥i cercas em tiles de grama ou terra, consumindo madeira.",
            "Machado": "<strong>Machado</strong><br>Corta √°rvores para obter madeira.",
            "Picareta": "<strong>Picareta</strong><br>Quebra pedras para obter minerais.",
            "Pedra": "<strong>Pedra</strong><br>Material de constru√ß√£o b√°sico, obtido de rochas.",
            "Madeira": "<strong>Madeira</strong><br>Material de constru√ß√£o b√°sico, obtido de √°rvores."
        };

        let gameHour = 0; let gameMinute = 0; let gameTimeOffset = 0;
        const GAME_MINUTES_PER_DAY = 1440; const REAL_SECONDS_PER_GAME_DAY = 3600;

        // --- Vari√°veis de Toque ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let touchHoldTimeout = null; // Timeout para detectar "hold"
        let isHolding = false; // Flag para indicar se est√° segurando para mover

        const preRenderedMapCanvas = document.createElement('canvas');
        preRenderedMapCanvas.width = MAP_WIDTH_PX; preRenderedMapCanvas.height = MAP_HEIGHT_PX;
        const preRenderedMapCtx = preRenderedMapCanvas.getContext('2d');
        preRenderedMapCtx.imageSmoothingEnabled = false;

        const waterSpritesheetCanvas = document.createElement('canvas');
        const waterSpritesheetCtx = waterSpritesheetCanvas.getContext('2d');
        waterSpritesheetCtx.imageSmoothingEnabled = false;

        const campfireSpritesheetCanvas = document.createElement('canvas');
        const campfireSpritesheetCtx = campfireSpritesheetCanvas.getContext('2d');
        campfireSpritesheetCtx.imageSmoothingEnabled = false;

        const torchSpritesheetCanvas = document.createElement('canvas');
        const torchSpritesheetCtx = torchSpritesheetCanvas.getContext('2d');
        torchSpritesheetCtx.imageSmoothingEnabled = false;

        // --- Fun√ß√µes de Desenho ---
        function drawGrassTile(ctx, x, y, size) { ctx.fillStyle = '#558B2F'; ctx.fillRect(x, y, size, size); ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; const pS = 4; for (let ty=0; ty<size; ty+=pS*2){ for(let tx=0; tx<size; tx+=pS*2){ ctx.fillRect(x+tx, y+ty, pS, pS); ctx.fillRect(x+tx+pS, y+ty+pS, pS, pS); } } }
        function drawEarthTile(ctx, x, y, size) { ctx.fillStyle = '#8D6E63'; ctx.fillRect(x, y, size, size); ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(x+5, y+10, 4, 4); ctx.fillRect(x+15, y+25, 4, 4); ctx.fillRect(x+22, y+8, 4, 4); ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(x+8, y+20, 3, 3); ctx.fillRect(x+18, y+5, 3, 3); ctx.fillRect(x+25, y+15, 3, 3); }
        function drawPlowedTile(ctx, x, y, size) { ctx.fillStyle = '#5D4037'; ctx.fillRect(x, y, size, size); ctx.fillStyle = '#A1887F'; const fH = 4; const s = 10; for(let fy=2; fy<size; fy+=s){ ctx.fillRect(x, y+fy, size, fH); } }
        function drawWaterTile(ctx, x, y, size) { ctx.fillStyle = '#1976D2'; ctx.fillRect(x, y, size, size); ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.fillRect(x+5, y+8, 10, 4); ctx.fillRect(x+18, y+20, 8, 4); ctx.fillRect(x+10, y+15, 6, 3); }
        function drawSeedTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#A1887F'; ctx.fillRect(x+8, y+6, 3, 3); ctx.fillRect(x+20, y+16, 3, 3); ctx.fillRect(x+12, y+26, 3, 3); }
        function drawSproutTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#8BC34A'; ctx.fillRect(x+13, y+10, 6, 8); ctx.fillRect(x+15, y+8, 2, 4); }
        function drawPlantTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#4CAF50'; ctx.fillRect(x+12, y+8, 8, 16); ctx.fillRect(x+8, y+12, 4, 8); ctx.fillRect(x+20, y+12, 4, 8); }
        function drawHarvestableTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#388E3C'; ctx.fillRect(x+10, y+5, 12, 22); ctx.fillRect(x+6, y+10, 4, 12); ctx.fillRect(x+22, y+10, 4, 12); ctx.fillStyle = '#E53935'; ctx.fillRect(x+14, y+14, 4, 4); ctx.fillRect(x+10, y+18, 4, 4); ctx.fillRect(x+18, y+18, 4, 4); }
        function drawRock(ctx, x_px, y_px) { ctx.fillStyle='#795548'; ctx.fillRect(x_px+4, y_px+10, 24, 18); ctx.fillStyle='#8D6E63'; ctx.fillRect(x_px+6, y_px+12, 20, 14); ctx.fillStyle='#5D4037'; ctx.fillRect(x_px+18, y_px+15, 6, 6); ctx.fillRect(x_px+8, y_px+20, 8, 8); }
        function drawTreeTrunk(ctx, x_px, y_px) { ctx.fillStyle='#5D4037'; ctx.fillRect(x_px+12, y_px+16, 8, TILE_SIZE-16); ctx.fillStyle='#795548'; ctx.fillRect(x_px+13, y_px+17, 6, TILE_SIZE-18); }
        function drawTreeCanopy(ctx, x_px, y_px) {
            const yT = y_px - TILE_SIZE * 1.5 + 8;
            const xC = x_px + TILE_SIZE / 2;
            
            // Verifica se o jogador est√° atr√°s da √°rvore
            const isPlayerBehind = player.y < y_px + TILE_SIZE && 
                                  player.y + player.height > y_px - TILE_SIZE && 
                                  player.x + player.width > x_px - TILE_SIZE && 
                                  player.x < x_px + TILE_SIZE * 2;

            // Define a opacidade baseada na posi√ß√£o do jogador
            ctx.globalAlpha = isPlayerBehind ? 0.3 : 1.0;

            // Desenha a copa mais escura
            ctx.fillStyle = '#388E3C';
            ctx.beginPath();
            ctx.ellipse(xC, yT + TILE_SIZE * 0.8, TILE_SIZE * 1.1, TILE_SIZE * 0.9, 0, 0, Math.PI * 2);
            ctx.ellipse(xC - TILE_SIZE * 0.5, yT + TILE_SIZE * 1.2, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(xC + TILE_SIZE * 0.5, yT + TILE_SIZE * 1.2, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Desenha a copa mais clara
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.ellipse(xC, yT + TILE_SIZE * 0.7, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(xC - TILE_SIZE * 0.4, yT + TILE_SIZE * 1.0, TILE_SIZE * 0.6, TILE_SIZE * 0.5, 0, 0, Math.PI * 2);
            ctx.ellipse(xC + TILE_SIZE * 0.4, yT + TILE_SIZE * 1.0, TILE_SIZE * 0.6, TILE_SIZE * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Restaura a opacidade original
            ctx.globalAlpha = 1.0;
        }
        function drawCampfire(ctx, x_px, y_px, timestamp) {
            // Logs
            ctx.fillStyle='#A1887F'; ctx.fillRect(x_px+10, y_px+20, 4, 6); ctx.fillRect(x_px+18, y_px+22, 4, 6); ctx.fillRect(x_px+14, y_px+24, 6, 4);
            ctx.fillStyle='#795548'; ctx.fillRect(x_px+12, y_px+21, 8, 2); ctx.fillRect(x_px+12, y_px+23, 8, 2);
            // Fogo mais vivo
            const fH=(Math.sin(timestamp*0.005)*0.1+0.9)*30;
            const fS1=Math.sin(timestamp*0.003)*1+3;
            const fS2=Math.sin(timestamp*0.0045)*0.8+0.5;
            const fS = fS1 + fS2; // Combina duas ondas para um pulso mais natural
            ctx.fillStyle=`hsl(${fH}, 100%, 50%)`; ctx.fillRect(x_px+14, y_px+16-fS, 4, 4+fS);
            ctx.fillStyle=`hsl(${fH+10}, 100%, 60%)`; ctx.fillRect(x_px+12, y_px+18-fS/2, 4, 4+fS/2); ctx.fillRect(x_px+18, y_px+18-fS/2, 4, 4+fS/2);
            // Fuma√ßa mais densa
            for (let i = 0; i < 5; i++) {
                const timeOffset = timestamp + i * 500;
                const sO = (timeOffset * 0.001) % (TILE_SIZE / 1.5);
                const opacity = Math.max(0, 0.4 - (sO / (TILE_SIZE / 1.5)) * 0.4);
                const size = 2 + (i % 2);
                const drift = Math.sin(timeOffset * 0.0005 + i) * 3;
                ctx.fillStyle=`rgba(180,180,180, ${opacity})`;
                ctx.fillRect(x_px + 15 + drift, y_px + 12 - sO * (1 + i * 0.1), size, size);
            }
        }
        function drawTorch(ctx, x_px, y_px, timestamp) { const tX=x_px+TILE_SIZE/2-2; const tY=y_px+TILE_SIZE/2; ctx.fillStyle='#795548'; ctx.fillRect(tX, tY, 4, 10); ctx.fillStyle='#A0A0A0'; ctx.fillRect(tX-1, tY-2, 6, 2); const fH=(Math.sin(timestamp*0.007)*0.1+0.9)*30; const fS=Math.sin(timestamp*0.004)*0.5+1.5; ctx.fillStyle=`hsl(${fH}, 100%, 50%)`; ctx.fillRect(tX+1, tY-6-fS, 2, 4+fS); ctx.fillStyle=`hsl(${fH+10}, 100%, 60%)`; ctx.fillRect(tX, tY-4-fS/2, 4, 2+fS/2); }
        function drawFence(ctx, x_px, y_px, orientation) {
            ctx.fillStyle = '#3E2723'; // Cor da madeira da cerca (marrom mais claro)
            if (orientation === 'horizontal') {
                // Poste esquerdo e direito
                ctx.fillRect(x_px + 4, y_px + 6, 4, 20);
                ctx.fillRect(x_px + 24, y_px + 6, 4, 20);
                // Barras horizontais
                ctx.fillRect(x_px + 4, y_px + 10, 24, 3);
                ctx.fillRect(x_px + 4, y_px + 18, 24, 3);
            } else { // 'vertical' ou padr√£o
                // Poste principal
                ctx.fillRect(x_px + 14, y_px + 4, 4, 24);
                // Barras curtas no poste
                ctx.fillRect(x_px + 10, y_px + 8, 12, 3);
                ctx.fillRect(x_px + 10, y_px + 18, 12, 3);
            }
        }
        function preRenderMap() { for(let y=0; y<MAP_HEIGHT_TILES; y++){ for(let x=0; x<MAP_WIDTH_TILES; x++){ updatePreRenderedTile(x, y, map[y][x]); } } console.log("Mapa pr√©-renderizado!"); }
        function updatePreRenderedTile(tileX, tileY, tileId) {
            const dX=tileX*TILE_SIZE; const dY=tileY*TILE_SIZE;
            // A √°gua (3) n√£o √© pr√©-renderizada, pois ser√° animada
            if (tileId === 3) {
                preRenderedMapCtx.clearRect(dX, dY, TILE_SIZE, TILE_SIZE);
                return;
            }
            switch(tileId){
                case 0: drawGrassTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 1: drawEarthTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 2: drawPlowedTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                // case 3: drawWaterTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break; // Removido daqui
                case 4: drawSeedTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 5: drawSproutTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 6: drawPlantTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 7: drawHarvestableTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                default: drawGrassTile(preRenderedMapCtx, dX, dY, TILE_SIZE);
            }
        }
        function drawPlayer(timestamp) { const px=player.x; const py=player.y; const w=player.width; const h=player.height; let fB=0; if(player.isMoving){fB=Math.sin(player.walkBob)*2;}else if(player.isUsingTool){const aP=(timestamp-player.toolAnimStart)/TOOL_ANIM_DURATION; fB=Math.abs(Math.sin(aP*Math.PI))*6;} const bH=py+fB; ctx.fillStyle=player.colorLegs; ctx.fillRect(px, bH+h*0.6, w*0.45, h*0.4); ctx.fillRect(px+w*0.55, bH+h*0.6, w*0.45, h*0.4); ctx.fillStyle=player.colorBody; ctx.fillRect(px, bH+h*0.3, w, h*0.4); const hX=px+w*0.1; const hY=bH; const hW=w*0.8; const hH=h*0.4; ctx.fillStyle=player.colorHead; ctx.fillRect(hX, hY, hW, hH); ctx.fillStyle='#000'; const eS=2; let e1x, e1y, e2x, e2y; if(player.lastMoveDir.dy===1){e1x=hX+hW*0.25; e1y=hY+hH*0.6; e2x=hX+hW*0.75-eS; e2y=hY+hH*0.6;}else if(player.lastMoveDir.dy===-1){e1x=hX+hW*0.25; e1y=hY+hH*0.2; e2x=hX+hW*0.75-eS; e2y=hY+hH*0.2;}else if(player.lastMoveDir.dx===-1){e1x=hX+hW*0.2; e1y=hY+hH*0.4; e2x=hX+hW*0.5-eS; e2y=hY+hH*0.4;}else if(player.lastMoveDir.dx===1){e1x=hX+hW*0.5; e1y=hY+hH*0.4; e2x=hX+hW*0.8-eS; e2y=hY+hH*0.4;} if(e1x){ctx.fillRect(e1x, e1y, eS, eS); ctx.fillRect(e2x, e2y, eS, eS);} }
        function drawWaterAnimation(anim, timestamp) { const el=timestamp-anim.startTime; const pr=el/anim.duration; if(pr>1)return; const x=anim.x*TILE_SIZE+TILE_SIZE/2; const y=anim.y*TILE_SIZE+TILE_SIZE/2; for(let i=0; i<5; i++){ const an=i*(Math.PI*2/5)+pr*2; const ra=5+pr*15; const dX=x+Math.cos(an)*ra; const dY=y+Math.sin(an)*ra; ctx.fillStyle=`rgba(100,181,246, ${1-pr})`; ctx.beginPath(); ctx.arc(dX, dY, 2, 0, 2*Math.PI); ctx.fill(); } }
        function drawAnimations(timestamp) { activeAnimations=activeAnimations.filter(an=>{const el=timestamp-an.startTime; if(el>an.duration)return false; if(an.type==='water'){drawWaterAnimation(an, timestamp);} return true;}); }
        function drawPlantTimers(timestamp) { ctx.font='bold 12px Consolas'; ctx.textAlign='center'; ctx.shadowColor='black'; ctx.shadowBlur=2; for(const key in plantGrowthData){ const[x,y]=key.split(',').map(Number); const data=plantGrowthData[key]; const tId=map[y][x]; if(tId>=4&&tId<=6){ const tP=timestamp-data.plantedAt; const eA=tP; let taT=0; if(tId===4)taT=GROWTH_TIME_SPROUT; else if(tId===5)taT=GROWTH_TIME_PLANT; else if(tId===6)taT=GROWTH_TIME_HARVEST; if(data.boosted){taT=taT*0.5;} const tL=Math.max(0, taT-eA); const sL=Math.ceil(tL/1000); const dX=x*TILE_SIZE+(TILE_SIZE/2); const dY=y*TILE_SIZE-5; ctx.fillStyle='white'; ctx.fillText(`${sL}s`, dX, dY); } } ctx.shadowBlur=0; }
        function updateGameTime() {
            const n=new Date(); const rH=n.getHours(); const rM=n.getMinutes(); const rS=n.getSeconds();
            const tS=(rH*3600 + rM*60 + rS) % (24 * 3600); // Segundos totais no dia real
            const p=tS/(24*3600); // Percentual do dia real
            let tM=Math.floor(GAME_MINUTES_PER_DAY*p); const oM=gameTimeOffset*60; tM=(tM+oM)%GAME_MINUTES_PER_DAY; gameHour=Math.floor(tM/60); gameMinute=tM%60;
            if (timeRangeSlider) { timeRangeSlider.value = gameHour; } // Sincroniza o slider com a hora do jogo
        }
        function updateNightOverlay() { if(!nightOverlay)return; const mO=0.7; let tO=0; if(gameHour>=20||gameHour<4)tO=mO; else if(gameHour===4)tO=mO*0.66; else if(gameHour===5)tO=mO*0.33; else if(gameHour>=6&&gameHour<18)tO=0; else if(gameHour===18)tO=mO*0.33; else if(gameHour===19)tO=mO*0.66; nightOverlay.style.opacity=tO; drawLighting(lastTime); }
        function drawTimeIcon() { timeIconCtx.clearRect(0,0,timeIconCanvas.width,timeIconCanvas.height); const cX=timeIconCanvas.width/2; const cY=timeIconCanvas.height/2; const r=8; if(gameHour>=6&&gameHour<18){timeIconCtx.fillStyle='#FFD700'; timeIconCtx.beginPath(); timeIconCtx.arc(cX,cY,r,0,Math.PI*2); timeIconCtx.fill();}else{timeIconCtx.fillStyle='#A0A0A0'; timeIconCtx.beginPath(); timeIconCtx.arc(cX,cY,r,0,Math.PI*2); timeIconCtx.fill(); timeIconCtx.fillStyle='rgba(0,0,0,0)'; timeIconCtx.globalCompositeOperation='destination-out'; timeIconCtx.beginPath(); timeIconCtx.arc(cX+r*0.4,cY-r*0.4,r,0,Math.PI*2); timeIconCtx.fill(); timeIconCtx.globalCompositeOperation='source-over';} }
        function drawGameClock() { if(!gameClockSpan)return; const hS=String(gameHour).padStart(2,'0'); const mS=String(gameMinute).padStart(2,'0'); gameClockSpan.textContent=`${hS}:${mS}`; drawTimeIcon(); }
        function drawLighting(timestamp) { lightCtx.clearRect(0,0,lightCanvas.width,lightCanvas.height); if(gameHour>=18||gameHour<6){ lightCtx.save(); const cNO=nightOverlay?parseFloat(nightOverlay.style.opacity):0; lightCtx.fillStyle=`rgba(0,0,30,${cNO*0.9})`; lightCtx.fillRect(0,0,lightCanvas.width,lightCanvas.height); lightCtx.globalCompositeOperation='destination-out'; for(const obj of mapObjects){ const xOS=obj.x*TILE_SIZE-camera.x; const yOS=obj.y*TILE_SIZE-camera.y; let lR=0; let lX=xOS+TILE_SIZE/2; let lY=yOS+TILE_SIZE/2; if(obj.type===2){lR=3.5*TILE_SIZE;}else if(obj.type===3){lR=2.5*TILE_SIZE; lY=yOS+TILE_SIZE*0.75;} if(lR>0){if(lX+lR>0&&lX-lR<lightCanvas.width&&lY+lR>0&&lY-lR<lightCanvas.height){ const pu=Math.sin(timestamp*0.005)*0.05+0.95; const gr=lightCtx.createRadialGradient(lX,lY,0,lX,lY,lR*pu); gr.addColorStop(0,'rgba(255,255,255,1)'); gr.addColorStop(0.3,'rgba(255,255,255,0.9)'); gr.addColorStop(0.7,'rgba(255,255,255,0.5)'); gr.addColorStop(1,'rgba(255,255,255,0)'); lightCtx.fillStyle=gr; lightCtx.beginPath(); lightCtx.arc(lX,lY,lR*pu,0,Math.PI*2); lightCtx.fill();}}} lightCtx.globalCompositeOperation='source-over'; lightCtx.restore();} }

        function updatePlayerMovement(timestamp) { if(player.isMoving){let dx=player.targetX-player.x; let dy=player.targetY-player.y; if(Math.abs(dx)<player.speed)player.x=player.targetX; else player.x+=Math.sign(dx)*player.speed; if(Math.abs(dy)<player.speed)player.y=player.targetY; else player.y+=Math.sign(dy)*player.speed; player.walkBob+=player.walkBobSpeed; if(player.x===player.targetX&&player.y===player.targetY){player.isMoving=false; player.walkBob=0; saveGame();}} }
        function updateToolAnimation(timestamp) { if(player.isUsingTool){if(timestamp-player.toolAnimStart>TOOL_ANIM_DURATION){player.isUsingTool=false; useTool(timestamp);}} }
        function updateAnimations(timestamp) { /* ... */ }
        function updateCamera() { const tX=player.x-(640/2)+(player.width/2); const tY=player.y-(480/2)+(player.height/2); camera.x=Math.max(0,Math.min(tX,MAP_WIDTH_PX-canvas.width)); camera.y=Math.max(0,Math.min(tY,MAP_HEIGHT_PX-canvas.height)); }
        function update(timestamp) { updatePlayerMovement(timestamp); updateToolAnimation(timestamp); updateAnimations(timestamp); updateCamera(); }
        function draw(timestamp) {
            const fireAnimFrame = Math.floor(timestamp / 150) % 8; // 8 quadros, muda a cada 150ms
            const waterAnimFrame = Math.floor(timestamp / 250) % 8; // 8 quadros, muda a cada 250ms

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-camera.x, -camera.y);
            // 1. Ch√£o
            ctx.drawImage(preRenderedMapCanvas, 0, 0);

            // 1.5. Desenha a √°gua animada
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    if (map[y][x] === 3) {
                        ctx.drawImage(waterSpritesheetCanvas, waterAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // 2. Coleta "desenh√°veis"
            let drawables = [];
            drawables.push({ type: 'player', x_px: player.x, y_px: player.y, y_sort: player.y + player.height - 4, draw: (ts) => drawPlayer(ts) });
            drawables.push({ type: 'shadow', x_px: player.x, y_px: player.y, y_sort: player.y + player.height - 5, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(player.x+player.width/2, player.y+player.height+2, player.width/2.5, 4, 0, 0, 2*Math.PI); ctx.fill();} });
            for (const obj of mapObjects) {
                const x_px = obj.x * TILE_SIZE; const y_px = obj.y * TILE_SIZE; const y_base = y_px + TILE_SIZE;
                if (obj.type === 0) { // Rocha
                     drawables.push({ type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base - 1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x_px+16, y_base, 12, 6, 0, 0, 2*Math.PI); ctx.fill();} });
                    drawables.push({ type: 'rock', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawRock(ctx, x_px, y_px) });
                } else if (obj.type === 1) { // √Årvore
                     drawables.push({ type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base -1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x_px+TILE_SIZE/2, y_base, TILE_SIZE*0.75, TILE_SIZE*0.4, 0, 0, 2*Math.PI); ctx.fill();} });
                    drawables.push({ type: 'tree_trunk', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawTreeTrunk(ctx, x_px, y_px) });
                    drawables.push({ type: 'tree_canopy', x_px: x_px, y_px: y_px, y_sort: y_base + TILE_SIZE * 2, draw: () => drawTreeCanopy(ctx, x_px, y_px) });
                } else if (obj.type === 2) { // Fogueira
                    drawables.push({ type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base - 1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x_px+16, y_base, 10, 5, 0, 0, 2*Math.PI); ctx.fill();} });
                    drawables.push({ type: 'campfire', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => ctx.drawImage(campfireSpritesheetCanvas, fireAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x_px, y_px, TILE_SIZE, TILE_SIZE) });
                } else if (obj.type === 3) { // Tocha
                    drawables.push({ type: 'torch', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => ctx.drawImage(torchSpritesheetCanvas, fireAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x_px, y_px, TILE_SIZE, TILE_SIZE) });
                } else if (obj.type === 4) { // Cerca - usa a orienta√ß√£o do objeto
                    drawables.push({ type: 'fence', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawFence(ctx, x_px, y_px, obj.orientation) });
                }
            }
            // 3. Ordena
            drawables.sort((a, b) => a.y_sort - b.y_sort);
            // 4. Desenha
            for (const item of drawables) { item.draw(timestamp); }
            // 5. Anima√ß√µes e Timers
            drawAnimations(timestamp); drawPlantTimers(timestamp);
            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) { if (!lastTime) lastTime = timestamp; lastTime = timestamp; update(timestamp); draw(timestamp); drawLighting(timestamp); requestAnimationFrame(gameLoop); }

        // --- L√≥gica do Jogo ---
        // CORRIGIDO: Keydown listener
        document.addEventListener('keydown', (e) => {
            // Teclas que funcionam mesmo com a mochila aberta
            if (e.key === 'b' || e.key === 'B') {
                console.log("Tecla B pressionada"); // DEBUG
                e.preventDefault();
                toggleBackpack();
                return;
            }
             if (e.key === 'Escape' && isBackpackOpen) {
                 e.preventDefault();
                 toggleBackpack(false); // For√ßa fechar
                 return;
             }

             // Bloqueia outras a√ß√µes se a mochila estiver aberta
             if (isBackpackOpen) {
                 // e.preventDefault(); // N√£o previne aqui, pode atrapalhar inputs futuros
                 return; // Simplesmente ignora a a√ß√£o no jogo
             }

             // Bloqueia se estiver se movendo ou usando ferramenta
             if (player.isMoving || player.isUsingTool) return;

            // Teclas 1-0 para Hotbar
            let slotIndex = -1;
            if (e.key >= '1' && e.key <= '9') { slotIndex = parseInt(e.key, 10) - 1; }
            else if (e.key === '0') { slotIndex = 9; }
            if (slotIndex !== -1) { e.preventDefault(); updateActiveHotbarSlot(slotIndex); return; }

            // Tecla Espa√ßo para Usar
            if (e.key === ' ') { e.preventDefault(); triggerUseTool(); return; }

            // Movimento com Setas
            let newDir = null;
            switch (e.key) { case 'ArrowUp': newDir = {dx:0, dy:-1}; break; case 'ArrowDown': newDir = {dx:0, dy:1}; break; case 'ArrowLeft': newDir = {dx:-1, dy:0}; break; case 'ArrowRight': newDir = {dx:1, dy:0}; break; }
            if (!newDir) return; // Ignora outras teclas
            triggerMovementOrTurn(newDir); // Chama a fun√ß√£o helper
        });

        // Fun√ß√£o helper para adicionar itens ao invent√°rio
        function addItemToInventory(itemName, quantity) {
            let itemIndex = backpackInventory.findIndex(i => i && i.name === itemName);
            if (itemIndex !== -1) {
                backpackInventory[itemIndex].count += quantity;
            } else {
                let emptyBackpackSlot = backpackInventory.findIndex(slot => slot === null);
                if (emptyBackpackSlot !== -1) {
                    backpackInventory[emptyBackpackSlot] = { name: itemName, count: quantity };
                    // Tenta mapear para um slot vazio da hotbar, se houver
                    let emptyHotbarSlot = hotbarMapping.findIndex(mapping => mapping === -1);
                    if (emptyHotbarSlot !== -1) {
                        hotbarMapping[emptyHotbarSlot] = emptyBackpackSlot;
                    }
                } else {
                    console.warn(`Mochila cheia, n√£o foi poss√≠vel adicionar ${quantity} de ${itemName}.`);
                }
            }
        }

        function useTool(timestamp) {
            const pX = Math.floor(player.x/TILE_SIZE); const pY = Math.floor(player.y/TILE_SIZE);
            const tX = pX + player.lastMoveDir.dx; const tY = pY + player.lastMoveDir.dy;
            if (tX < 0 || tX >= MAP_WIDTH_TILES || tY < 0 || tY >= MAP_HEIGHT_TILES) return;

            const bpIdx = hotbarMapping[activeHotbarSlot];
            if (bpIdx < 0 || bpIdx >= backpackInventory.length) return;
            const item = backpackInventory[bpIdx];
            if (!item) return;

            // Verifica se h√° um objeto no tile alvo
            const objectIndex = mapObjects.findIndex(obj => obj.x === tX && obj.y === tY);
            if (objectIndex !== -1) {
                const targetObject = mapObjects[objectIndex];
                if (item.name === "Picareta" && targetObject.type === 0) { // Rocha
                    mapObjects.splice(objectIndex, 1); // Remove a rocha
                    const stoneGained = Math.floor(Math.random() * 11) + 5; // Ganho de 5 a 15 pedras
                    addItemToInventory("Pedra", stoneGained);
                    console.log(`Rocha quebrada! Ganhou ${stoneGained} pedras.`);
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // A√ß√£o conclu√≠da
                }
                if (item.name === "Machado" && targetObject.type === 1) { // √Årvore
                    mapObjects.splice(objectIndex, 1); // Remove a √°rvore
                    const woodGained = Math.floor(Math.random() * 11) + 5; // Ganho de 5 a 15 madeiras
                    addItemToInventory("Madeira", woodGained);
                    console.log(`√Årvore cortada! Ganhou ${woodGained} madeiras.`);
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // A√ß√£o conclu√≠da
                }
                if (item.name === "P√°" && targetObject.type === 4) { // Cerca
                    mapObjects.splice(objectIndex, 1); // Remove a cerca
                    addItemToInventory("Madeira", 1); // Devolve 1 madeira
                    console.log("Cerca removida!");
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // A√ß√£o conclu√≠da
                }
                if (item.name === "P√°" && targetObject.type === 4) { // Cerca
                    mapObjects.splice(objectIndex, 1); // Remove a cerca
                    addItemToInventory("Madeira", 1); // Devolve 1 madeira
                    console.log("Cerca removida!");
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // A√ß√£o conclu√≠da
                }

                return; // Impede o uso da ferramenta no ch√£o se houver um objeto
            }

            // Se n√£o houver objeto, continua com a l√≥gica para o ch√£o
            const tK = `${tX},${tY}`;
            const tId = map[tY][tX];

            // L√≥gica de Colheita
            if (tId === 7) {
                map[tY][tX] = 2; // Volta para solo arado
                delete plantGrowthData[tK]; // Remove os dados de crescimento da planta
                addItemToInventory("Colheita", 1);
                const seedsGained = Math.floor(Math.random() * 4); // 0, 1, 2 ou 3 sementes
                if (seedsGained > 0) addItemToInventory("Semente", seedsGained);
                updatePreRenderedTile(tX, tY, 2);
                saveGame(); updateHotbarUI(); updateBackpackUI(); return;
            }

            switch (item.name) {
                case "Enxada": if (tId === 0 || tId === 1) { map[tY][tX] = 2; updatePreRenderedTile(tX, tY, 2); saveGame(); } break;
                case "Semente": if (tId === 2 && item.count > 0) { map[tY][tX] = 4; plantGrowthData[tK] = { plantedAt: timestamp, boosted: false }; item.count--; updatePreRenderedTile(tX, tY, 4); saveGame(); updateHotbarUI(); updateBackpackUI(); } break;
                case "P√°": if (tId === 1 || tId === 2 || (tId >= 4 && tId <= 7)) { map[tY][tX] = 0; if (plantGrowthData[tK]) delete plantGrowthData[tK]; updatePreRenderedTile(tX, tY, 0); saveGame(); } else if (tId === 0) { let aW = false; const ne = [[0, 1], [0, -1], [1, 0], [-1, 0]]; for (const [nx, ny] of ne) { const cX = tX + nx; const cY = tY + ny; if (cX >= 0 && cX < MAP_WIDTH_TILES && cY >= 0 && cY < MAP_HEIGHT_TILES) { if (map[cY][cX] === 3) { aW = true; break; } } } if (aW) { map[tY][tX] = 3; updatePreRenderedTile(tX, tY, 3); saveGame(); } } else if (tId === 3) { map[tY][tX] = 0; updatePreRenderedTile(tX, tY, 0); saveGame(); } break;
                case "Regador": if (tId === 3) { item.count = 10; updateHotbarUI(); updateBackpackUI(); saveGame(); } else if (tId >= 4 && tId <= 6 && item.count > 0) { const pD = plantGrowthData[tK]; if (pD && !pD.boosted) { pD.boosted = true; item.count--; activeAnimations.push({ type: 'water', x: tX, y: tY, startTime: timestamp, duration: 500 }); updateHotbarUI(); updateBackpackUI(); saveGame(); } } break;
                case "Martelo":
                    if ((tId === 0 || tId === 1) && objectIndex === -1) { // Pode construir em grama ou terra vazia
                        const woodIdx = backpackInventory.findIndex(i => i && i.name === "Madeira");
                        if (woodIdx !== -1 && backpackInventory[woodIdx].count > 0) {
                            backpackInventory[woodIdx].count--;
                            const orientation = (player.lastMoveDir.dx !== 0) ? 'vertical' : 'horizontal';
                            mapObjects.push({ type: 4, x: tX, y: tY, orientation: orientation });
                            console.log("Cerca constru√≠da!");
                            saveGame();
                            updateHotbarUI();
                            updateBackpackUI();
                        } else {
                            console.log("Sem madeira para construir a cerca.");
                        }
                    }
                    break;
                case "Machado": console.log("Usou Machado no ch√£o"); break; // A√ß√£o em objeto j√° tratada
                case "Picareta": console.log("Usou Picareta no ch√£o"); break; // A√ß√£o em objeto j√° tratada
            }
        }

        function isWalkable(pixelX, pixelY) { const tX=Math.floor(pixelX/TILE_SIZE); const tY=Math.floor(pixelY/TILE_SIZE); if(tX<0||tX>=MAP_WIDTH_TILES||tY<0||tY>=MAP_HEIGHT_TILES)return false; if(map[tY][tX]===3)return false; for(const obj of mapObjects){if(obj.x===tX&&obj.y===tY){if(obj.type===0||obj.type===1||obj.type===2||obj.type===4)return false;}} return true; }

        function updatePlantGrowth(timestamp) { let mC=false; for(const key in plantGrowthData){ const[x,y]=key.split(',').map(Number); const data=plantGrowthData[key]; const tP=timestamp-data.plantedAt; const eA=tP; const cId=map[y][x]; const bM=data.boosted?0.5:1; const tS=GROWTH_TIME_SPROUT*bM; const tP_=GROWTH_TIME_PLANT*bM; const tH=GROWTH_TIME_HARVEST*bM; let nId=-1; if(eA>tH&&cId===6)nId=7; else if(eA>tP_&&cId===5)nId=6; else if(eA>tS&&cId===4)nId=5; if(nId!==-1){map[y][x]=nId; updatePreRenderedTile(x,y,nId); mC=true;} } if(mC){saveGame();} }
        function startGrowthTimer() { setInterval(() => { updatePlantGrowth(lastTime); }, 1000); }

        // --- Fun√ß√µes de UI ---
        // CORRIGIDO: updateHotbarUI e updateBackpackUI
        function updateHotbarUI() {
            const slots = hotbarElement.querySelectorAll('.slot');
            slots.forEach((slot, hotbarIndex) => {
                const backpackIndex = hotbarMapping[hotbarIndex];
                const item = (backpackIndex !== -1 && backpackIndex >= 0 && backpackIndex < backpackInventory.length) ? backpackInventory[backpackIndex] : null;
                const nameSpan = slot.querySelector('.slot-name');
                const countSpan = slot.querySelector('.slot-count');

                if (item && nameSpan && countSpan) {
                    nameSpan.textContent = item.name;
                    countSpan.textContent = (item.count > 0 && ["Semente", "Colheita", "Regador", "Pedra", "Madeira"].includes(item.name)) ? item.count : "";
                } else if (nameSpan && countSpan) {
                    nameSpan.textContent = "";
                    countSpan.textContent = "";
                }
                slot.classList.toggle('active', hotbarIndex === activeHotbarSlot);
                slot.classList.remove('dragging', 'drag-over');
            });
        }

        function updateBackpackUI() {
            backpackGrid.innerHTML = '';
            backpackInventory.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.classList.add('slot');
                slot.dataset.backpackIndex = index;

                const nameSpan = document.createElement('span');
                nameSpan.classList.add('slot-name');

                const countSpan = document.createElement('span');
                countSpan.classList.add('slot-count');

                if (item) {
                    nameSpan.textContent = item.name;
                    countSpan.textContent = (item.count > 0 && ["Semente", "Colheita", "Regador", "Pedra", "Madeira"].includes(item.name)) ? item.count : "";
                } else {
                    nameSpan.textContent = "";
                    countSpan.textContent = "";
                }

                slot.appendChild(nameSpan);
                slot.appendChild(countSpan);

                if (index === selectedBackpackIndex) { slot.classList.add('selected-for-assignment'); }
                slot.addEventListener('click', handleBackpackSlotClick);
                // Adiciona listeners para o tooltip
                slot.addEventListener('mouseover', showTooltip);
                slot.addEventListener('mouseout', hideTooltip);
                backpackGrid.appendChild(slot);
            });
        }

        // --- L√≥gica do Tooltip ---
        function showTooltip(event) {
            const slot = event.currentTarget;
            let itemName = null;

            if (slot.parentElement.id === 'hotbar') {
                const hotbarIndex = parseInt(slot.dataset.hotbarIndex, 10);
                const backpackIndex = hotbarMapping[hotbarIndex];
                if (backpackIndex !== -1 && backpackInventory[backpackIndex]) {
                    itemName = backpackInventory[backpackIndex].name;
                }
            } else if (slot.parentElement.id === 'backpackGrid') {
                const backpackIndex = parseInt(slot.dataset.backpackIndex, 10);
                if (backpackInventory[backpackIndex]) {
                    itemName = backpackInventory[backpackIndex].name;
                }
            }

            if (itemName && itemDescriptions[itemName]) {
                const slotRect = slot.getBoundingClientRect();
                const containerRect = gameContainer.getBoundingClientRect();

                itemTooltip.innerHTML = itemDescriptions[itemName];
                itemTooltip.style.display = 'block';

                // Calcula a posi√ß√£o ideal (acima e centralizado)
                let top = slotRect.top - containerRect.top - itemTooltip.offsetHeight - 10; // 10px de margem
                let left = slotRect.left - containerRect.left + (slotRect.width / 2) - (itemTooltip.offsetWidth / 2);

                // Garante que n√£o saia pelos lados
                if (left < 5) left = 5;
                if (left + itemTooltip.offsetWidth > containerRect.width - 5) {
                    left = containerRect.width - itemTooltip.offsetWidth - 5;
                }
                // Se sair por cima, mostra embaixo
                if (top < 5) {
                    top = slotRect.top - containerRect.top + slotRect.height + 10;
                }

                itemTooltip.style.top = `${top}px`;
                itemTooltip.style.left = `${left}px`;
            }
        }

        function hideTooltip() {
            itemTooltip.style.display = 'none';
        }

        function updateActiveHotbarSlot(hotbarIndex) { if (hotbarIndex >= 0 && hotbarIndex < HOTBAR_SIZE) { activeHotbarSlot = hotbarIndex; saveGame(); updateHotbarUI(); } }

        // --- L√≥gica Mochila ---
        function toggleBackpack(forceState = null) {
            console.log("toggleBackpack chamado. Estado atual:", isBackpackOpen, "For√ßar:", forceState); // DEBUG
            isBackpackOpen = (forceState !== null) ? forceState : !isBackpackOpen;
            console.log("Novo estado:", isBackpackOpen); // DEBUG
            if (isBackpackOpen) {
                selectedBackpackIndex = -1; updateBackpackUI(); backpackContainer.style.display = 'flex';
            } else {
                backpackContainer.style.display = 'none';
                const sel = backpackGrid.querySelector('.selected-for-assignment'); if(sel) sel.classList.remove('selected-for-assignment');
            }
        }

        function handleBackpackSlotClick(event) {
             if (!isBackpackOpen) return;
             const clickedIndex = parseInt(event.currentTarget.dataset.backpackIndex, 10);
             const prevSel = backpackGrid.querySelector('.selected-for-assignment'); if (prevSel) prevSel.classList.remove('selected-for-assignment');
             if (clickedIndex === selectedBackpackIndex) { selectedBackpackIndex = -1; }
             else { selectedBackpackIndex = clickedIndex; event.currentTarget.classList.add('selected-for-assignment'); console.log(`Selecionado item da mochila: ${selectedBackpackIndex}`); }
        }

        function handleHotbarSlotClick(event) {
            const clickedHotbarIndex = parseInt(event.currentTarget.dataset.hotbarIndex, 10);
            if (isBackpackOpen) {
                if (selectedBackpackIndex !== -1) {
                    console.log(`Atribuindo mochila[${selectedBackpackIndex}] -> hotbar[${clickedHotbarIndex}]`);
                    const existingHotbarSlot = hotbarMapping.indexOf(selectedBackpackIndex);
                    if(existingHotbarSlot !== -1) { hotbarMapping[existingHotbarSlot] = -1; }
                    hotbarMapping[clickedHotbarIndex] = selectedBackpackIndex;
                    selectedBackpackIndex = -1;
                    updateBackpackUI(); updateHotbarUI(); saveGame();
                }
            } else {
                if (clickedHotbarIndex === activeHotbarSlot && !player.isMoving && !player.isUsingTool) {
                     const bpIdx = hotbarMapping[activeHotbarSlot];
                     if(bpIdx !== -1 && backpackInventory[bpIdx]){
                        console.log("Clique para usar slot ativo:", activeHotbarSlot); // DEBUG
                        triggerUseTool(); // Chama a fun√ß√£o helper
                     }
                } else {
                    updateActiveHotbarSlot(clickedHotbarIndex);
                }
            }
        }


        // --- L√≥gica Drag & Drop ---
        let draggedHotbarIndex = -1;
        function handleDragStart(event) { if(isBackpackOpen) { event.preventDefault(); return; } const targetSlot = event.target.closest('.slot'); if(!targetSlot || !targetSlot.dataset.hotbarIndex) { event.preventDefault(); return; } draggedHotbarIndex = parseInt(targetSlot.dataset.hotbarIndex, 10); event.dataTransfer.setData('text/plain', draggedHotbarIndex); event.dataTransfer.effectAllowed = 'move'; setTimeout(() => targetSlot.classList.add('dragging'), 0); console.log("Drag Start:", draggedHotbarIndex); }
        function handleDragOver(event) { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetSlot = event.target.closest('.slot'); if(targetSlot && targetSlot.parentElement.id === 'hotbar'){ hotbarElement.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); targetSlot.classList.add('drag-over'); } }
        function handleDragLeave(event) { const targetSlot = event.target.closest('.slot'); if(targetSlot && targetSlot.parentElement.id === 'hotbar'){ targetSlot.classList.remove('drag-over'); } }
        function handleDrop(event) {
            event.preventDefault();
            const targetSlot = event.target.closest('.slot');
            if (!targetSlot || draggedHotbarIndex === -1 || targetSlot.parentElement.id !== 'hotbar') { cleanupDragDrop(); return; }
            const droppedOnHotbarIndex = parseInt(targetSlot.dataset.hotbarIndex, 10);
            console.log("Drop:", draggedHotbarIndex, "onto", droppedOnHotbarIndex);
            if (draggedHotbarIndex !== droppedOnHotbarIndex) {
                const sourceMapping = hotbarMapping[draggedHotbarIndex];
                const targetMapping = hotbarMapping[droppedOnHotbarIndex];
                hotbarMapping[draggedHotbarIndex] = targetMapping;
                hotbarMapping[droppedOnHotbarIndex] = sourceMapping;
                saveGame(); updateHotbarUI();
            }
            cleanupDragDrop();
        }
        function handleDragEnd(event) { cleanupDragDrop(); }
        function cleanupDragDrop(){ draggedHotbarIndex = -1; hotbarElement.querySelectorAll('.slot').forEach(slot => { slot.classList.remove('dragging', 'drag-over'); }); console.log("Drag End / Cleanup"); }


        // --- Persist√™ncia ---
        function ensureInventoryConsistency(backpack, mapping, defaultItems) {
            while(backpack.length < BACKPACK_SIZE) backpack.push(null); if(backpack.length > BACKPACK_SIZE) backpack.length = BACKPACK_SIZE;
            while(mapping.length < HOTBAR_SIZE) mapping.push(-1); if(mapping.length > HOTBAR_SIZE) mapping.length = HOTBAR_SIZE;
             defaultItems.forEach((defaultItem, defaultIndex) => {
                 let foundIndex = backpack.findIndex(i => i && i.name === defaultItem.name);
                 if(foundIndex === -1) {
                     let emptySlotIndex = backpack.findIndex(slot => slot === null);
                     if (emptySlotIndex !== -1) {
                         backpack[emptySlotIndex] = { ...defaultItem };
                         foundIndex = emptySlotIndex;
                         console.log(`Adicionado item padr√£o "${defaultItem.name}" no slot vazio ${foundIndex}`);
                     } else { console.warn(`Mochila cheia, n√£o foi poss√≠vel adicionar item padr√£o "${defaultItem.name}"`); }
                 }
                 if (defaultIndex < HOTBAR_SIZE && mapping[defaultIndex] === -1 && foundIndex !== -1) {
                      const isMappedElsewhere = mapping.includes(foundIndex);
                      if (!isMappedElsewhere) { mapping[defaultIndex] = foundIndex; console.log(`Mapeado item padr√£o "${defaultItem.name}" (mochila ${foundIndex}) para hotbar ${defaultIndex}`); }
                 }
            });
            for (let i = 0; i < mapping.length; i++) { if (mapping[i] !== -1 && (mapping[i] >= BACKPACK_SIZE || !backpack[mapping[i]])) { console.log(`Limpando mapeamento inv√°lido da hotbar ${i} (apontava para ${mapping[i]})`); mapping[i] = -1; } }
        }
        function saveGame() {
            const saveData = {
                player: {
                    x: player.x,
                    y: player.y,
                    lastMoveDir: { dx: player.lastMoveDir.dx, dy: player.lastMoveDir.dy }
                },
                map: map,
                mapObjects: mapObjects,
                plantData: plantGrowthData,
                backpackData: backpackInventory,
                hotbarMapData: hotbarMapping,
                activeSlotData: activeHotbarSlot,
                gameTimeOffset: gameTimeOffset
            };
            localStorage.setItem('pixelFarmSaveData', JSON.stringify(saveData));
            console.log("Jogo salvo!");
        }
        // CORRIGIDO: loadGame
        function loadGame() {
            const defaultItems = [ { name: "Enxada", count: 1 }, { name: "Semente", count: 10 }, { name: "Colheita", count: 0 }, { name: "P√°", count: 1 }, { name: "Regador", count: 0 }, { name: "Martelo", count: 1 }, { name: "Machado", count: 1 }, { name: "Picareta", count: 1 }, { name: "Pedra", count: 0 }, { name: "Madeira", count: 0 } ];

            const savedData = localStorage.getItem('pixelFarmSaveData');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    // Carrega TUDO do save primeiro
                    if (data.map) map = data.map;
                    if (data.player) {
                        if (typeof data.player.x === 'number') player.x = data.player.x;
                        if (typeof data.player.y === 'number') player.y = data.player.y;
                        if (data.player.lastMoveDir && typeof data.player.lastMoveDir.dx === 'number' && typeof data.player.lastMoveDir.dy === 'number') {
                            player.lastMoveDir = { dx: data.player.lastMoveDir.dx, dy: data.player.lastMoveDir.dy };
                        }
                        // Garante que o player n√£o comece se movendo ou com target diferente
                        player.targetX = player.x;
                        player.targetY = player.y;
                        player.isMoving = false;
                    }
                    if (data.mapObjects) { mapObjects = data.mapObjects.filter(obj => { if (!obj || typeof obj.x !== 'number' || typeof obj.y !== 'number') return false; if (obj.x < 0 || obj.x >= MAP_WIDTH_TILES || obj.y < 0 || obj.y >= MAP_HEIGHT_TILES) { console.warn(`Objeto em [${obj.x},${obj.y}] removido pois est√° fora do mapa.`); return false; } if ((obj.type === 0 || obj.type === 1 || obj.type === 2) && obj.y >= 0 && obj.y < map.length && obj.x >= 0 && obj.x < map[obj.y].length && map[obj.y][obj.x] === 3) { console.warn(`Objeto (tipo ${obj.type}) em [${obj.x},${obj.y}] removido pois est√° na √°gua.`); return false; } return true; }); }
                    if (data.plantData) { for (const key in data.plantData) { const plant = data.plantData[key]; if (typeof plant.boost === 'number' && plant.boost > 0) { plant.boosted = true; delete plant.boost; } else if (typeof plant.boosted === 'undefined') { plant.boosted = false; } } plantGrowthData = data.plantData; }
                    if (data.activeSlotData !== undefined && data.activeSlotData >= 0 && data.activeSlotData < HOTBAR_SIZE) { activeHotbarSlot = data.activeSlotData; }

                    // Carrega invent√°rio e hotbar do save, ou usa arrays vazios se n√£o existirem
                    backpackInventory = (data.backpackData && Array.isArray(data.backpackData)) ? data.backpackData : new Array(BACKPACK_SIZE).fill(null);
                    hotbarMapping = (data.hotbarMapData && Array.isArray(data.hotbarMapData)) ? data.hotbarMapData : new Array(HOTBAR_SIZE).fill(-1);

                    if (typeof data.gameTimeOffset === 'number') { gameTimeOffset = data.gameTimeOffset; }

                    // Re-valida a consist√™ncia AP√ìS carregar, para limpar mapeamentos ruins do save
                    // e adicionar itens padr√£o caso o save seja de uma vers√£o antiga.
                    ensureInventoryConsistency(backpackInventory, hotbarMapping, defaultItems);

                    console.log("Jogo carregado.");
                } catch (e) {
                    console.error("Erro ao carregar o save, usando dados padr√£o.", e);
                     // Reset em caso de erro de parse - cria um jogo novo
                     backpackInventory = new Array(BACKPACK_SIZE).fill(null); hotbarMapping = new Array(HOTBAR_SIZE).fill(-1); ensureInventoryConsistency(backpackInventory, hotbarMapping, defaultItems); activeHotbarSlot = 0; gameTimeOffset = 0;
                     mapObjects = mapObjects.filter(obj => { if (!obj || typeof obj.x !== 'number' || typeof obj.y !== 'number') return false; if (obj.x < 0 || obj.x >= MAP_WIDTH_TILES || obj.y < 0 || obj.y >= MAP_HEIGHT_TILES) return false; if ((obj.type === 0 || obj.type === 1 || obj.type === 2) && obj.y >= 0 && obj.y < map.length && obj.x >= 0 && obj.x < map[obj.y].length && map[obj.y][obj.x] === 3) return false; return true; });
                     plantGrowthData = {};
                }
            } else {
                console.log("Nenhum save encontrado, iniciando novo jogo.");
                // Garante itens e mapeamento padr√£o para novo jogo (j√° feito no in√≠cio da fun√ß√£o)
                backpackInventory = new Array(BACKPACK_SIZE).fill(null);
                hotbarMapping = new Array(HOTBAR_SIZE).fill(-1);
                activeHotbarSlot = 0;
                mapObjects = mapObjects.filter(obj => { if (!obj || typeof obj.x !== 'number' || typeof obj.y !== 'number') return false; if (obj.x < 0 || obj.x >= MAP_WIDTH_TILES || obj.y < 0 || obj.y >= MAP_HEIGHT_TILES) return false; if ((obj.type === 0 || obj.type === 1 || obj.type === 2) && obj.y >= 0 && obj.y < map.length && obj.x >= 0 && obj.x < map[obj.y].length && map[obj.y][obj.x] === 3) return false; return true; });
                ensureInventoryConsistency(backpackInventory, hotbarMapping, defaultItems);
            }
        }


        // --- Fun√ß√µes Helper para Controles (CORRIGIDO) ---
        function triggerUseTool() {
             // Bloqueia se mochila aberta ou j√° em a√ß√£o
             if (isBackpackOpen || player.isMoving || player.isUsingTool) return;

             const bpIdx = hotbarMapping[activeHotbarSlot];
            
             if (bpIdx === -1 || bpIdx >= backpackInventory.length || !backpackInventory[bpIdx]) return; // Slot vazio ou inv√°lido

             console.log("Trigger Use Tool - Slot:", activeHotbarSlot);
             player.isMoving = false; // Garante que parou de andar
             player.isUsingTool = true;
             player.toolAnimStart = lastTime; // Usa o timestamp do loop
        }

        function triggerMovementOrTurn(newDir) {
             // Bloqueia se mochila aberta ou j√° em a√ß√£o
             if (isBackpackOpen || player.isMoving || player.isUsingTool) return;

             const isFacing = (player.lastMoveDir.dx === newDir.dx && player.lastMoveDir.dy === newDir.dy);
             if (!isFacing) {
                 player.lastMoveDir = newDir;
                 console.log("Turn:", newDir);
             } else {
                 const tX = player.targetX + newDir.dx * TILE_SIZE;
                 const tY = player.targetY + newDir.dy * TILE_SIZE;
                 if (isWalkable(tX, tY)) {
                     player.isMoving = true;
                     player.targetX = tX;
                     player.targetY = tY;
                     console.log("Move:", newDir);
                 } else {
                      console.log("Blocked:", newDir); // Log se o movimento for bloqueado
                 }
             }
         }

         // --- Listeners de Toque (CORRIGIDO) ---
         function handleTouchStart(e) {
             e.preventDefault();
             if (isBackpackOpen || player.isMoving || player.isUsingTool) return; // Bloqueia tudo se mochila aberta ou em a√ß√£o

             const touch = e.touches[0];
             const rect = canvas.getBoundingClientRect();
             touchStartX = touch.clientX - rect.left;
             touchStartY = touch.clientY - rect.top;
             touchStartTime = Date.now();
             isHolding = false;
             console.log("Touch Start:", touchStartX, touchStartY);

             clearTimeout(touchHoldTimeout);
             touchHoldTimeout = setTimeout(() => {
                 // Verifica novamente se a mochila foi aberta nesse meio tempo
                 if (isBackpackOpen || player.isMoving || player.isUsingTool) return;

                 isHolding = true;
                 const playerScreenX = player.x - camera.x + (player.width / 2);
                 const playerScreenY = player.y - camera.y + (player.height / 2);
                 const diffX = touchStartX - playerScreenX;
                 const diffY = touchStartY - playerScreenY;
                 const absDiffX = Math.abs(diffX);
                 const absDiffY = Math.abs(diffY);

                 if (absDiffX > TOUCH_MOVE_THRESHOLD || absDiffY > TOUCH_MOVE_THRESHOLD) {
                      let moveDir = { dx: 0, dy: 0 };
                     if (absDiffX > absDiffY) { moveDir.dx = Math.sign(diffX); }
                     else { moveDir.dy = Math.sign(diffY); }
                     console.log("Hold detected - Triggering Movement:", moveDir);
                     triggerMovementOrTurn(moveDir);
                 }
             }, TAP_TIME_THRESHOLD);
         }
         function handleTouchMove(e) {
             e.preventDefault();
             if (isBackpackOpen || !isHolding || player.isUsingTool) return; // Ignora se mochila aberta, n√£o for hold, ou usando ferramenta

             // Se est√° segurando (isHolding = true) E N√ÉO est√° se movendo (isMoving = false), tenta iniciar o movimento
             // Se J√Å est√° se movendo (isMoving = true), n√£o faz nada aqui (deixa o update cuidar)
             if (!player.isMoving) {
                 const playerScreenX = player.x - camera.x + (player.width / 2);
                 const playerScreenY = player.y - camera.y + (player.height / 2);
                 const touch = e.touches[0];
                 const rect = canvas.getBoundingClientRect();
                 const currentX = touch.clientX - rect.left;
                 const currentY = touch.clientY - rect.top;

                 const diffX = currentX - playerScreenX;
                 const diffY = currentY - playerScreenY;
                 const absDiffX = Math.abs(diffX);
                 const absDiffY = Math.abs(diffY);

                 if (absDiffX > TOUCH_MOVE_THRESHOLD || absDiffY > TOUCH_MOVE_THRESHOLD) {
                     let moveDir = { dx: 0, dy: 0 };
                     if (absDiffX > absDiffY) { moveDir.dx = Math.sign(diffX); }
                     else { moveDir.dy = Math.sign(diffY); }
                     console.log("Touch Move (Hold Active) - Triggering Movement:", moveDir);
                     triggerMovementOrTurn(moveDir); // Tenta iniciar/continuar movimento
                 }
            }
         }
         function handleTouchEnd(e) {
             e.preventDefault();
             clearTimeout(touchHoldTimeout); // Limpa o timeout de hold

             if (isBackpackOpen) { isHolding = false; return; } // Ignora se mochila aberta

             const touchDuration = Date.now() - touchStartTime;

             // Se foi r√°pido e n√£o virou hold -> TAP
             if (!isHolding && touchDuration < TAP_TIME_THRESHOLD) {
                 console.log("Tap detected.");
                  // Ignora se estiver se movendo ou usando ferramenta (pode ter sido iniciado no timeout)
                 if (player.isMoving || player.isUsingTool) {
                     console.log("Tap ignored - player busy.");
                     isHolding = false; // Reset state
                     return;
                 }

                 const touchedWorldX = touchStartX + camera.x;
                 const touchedWorldY = touchStartY + camera.y;
                 const touchedTileX = Math.floor(touchedWorldX / TILE_SIZE);
                 const touchedTileY = Math.floor(touchedWorldY / TILE_SIZE);
                 const facingTileX = Math.floor((player.targetX)/TILE_SIZE) + player.lastMoveDir.dx; // Usa targetX
                 const facingTileY = Math.floor((player.targetY)/TILE_SIZE) + player.lastMoveDir.dy; // Usa targetY

                 console.log("Tap Info - Facing:", facingTileX, facingTileY, "Touched:", touchedTileX, touchedTileY);

                 if (touchedTileX === facingTileX && touchedTileY === facingTileY) {
                     console.log("Tap on facing tile - Triggering Use Tool");
                     triggerUseTool();
                 } else {
                     const playerScreenX = player.x - camera.x + (player.width / 2);
                     const playerScreenY = player.y - camera.y + (player.height / 2);
                     const diffX = touchStartX - playerScreenX;
                     const diffY = touchStartY - playerScreenY;
                     const absDiffX = Math.abs(diffX);
                     const absDiffY = Math.abs(diffY);

                     let tapDir = { dx: 0, dy: 0 };
                     if (absDiffX > absDiffY) { tapDir.dx = Math.sign(diffX); }
                     else { tapDir.dy = Math.sign(diffY); }

                     if ((tapDir.dx !== 0 || tapDir.dy !== 0)) {
                         player.lastMoveDir = tapDir;
                         console.log("Tap turn:", tapDir);
                     }
                 }
             } else {
                  console.log("Hold/Drag End.");
                  // Se estava segurando (isHolding=true), o movimento j√° foi iniciado.
                  // Aqui apenas limpamos o estado. O movimento parar√° no updatePlayerMovement.
             }

             isHolding = false; // Reseta estado de hold ao soltar
         }

        function generateWaterSpritesheet() {
            const NUM_FRAMES = 8;
            waterSpritesheetCanvas.width = TILE_SIZE * NUM_FRAMES;
            waterSpritesheetCanvas.height = TILE_SIZE;

            for (let i = 0; i < NUM_FRAMES; i++) {
                const x = i * TILE_SIZE;
                const y = 0;
                
                // Base
                waterSpritesheetCtx.fillStyle = '#1976D2';
                waterSpritesheetCtx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                // Highlights animados
                waterSpritesheetCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                const yOffset1 = Math.sin((i / NUM_FRAMES) * Math.PI * 2) * 3;
                const yOffset2 = Math.cos((i / NUM_FRAMES) * Math.PI * 2) * 2;
                waterSpritesheetCtx.fillRect(x + 5, y + 8 + yOffset1, 10, 4);
                waterSpritesheetCtx.fillRect(x + 18, y + 20 - yOffset1, 8, 3);
                waterSpritesheetCtx.fillRect(x + 10, y + 15 + yOffset2, 6, 3);
            }
            console.log("Spritesheet de √°gua gerado.");
        }

        function generateCampfireSpritesheet() {
            const NUM_FRAMES = 8;
            campfireSpritesheetCanvas.width = TILE_SIZE * NUM_FRAMES;
            campfireSpritesheetCanvas.height = TILE_SIZE;
            const frameDuration = 150; // Dura√ß√£o simulada para capturar a anima√ß√£o

            for (let i = 0; i < NUM_FRAMES; i++) {
                const x = i * TILE_SIZE;
                const simulatedTimestamp = i * frameDuration;
                // A fun√ß√£o drawCampfire desenha relativo ao x,y que passamos
                drawCampfire(campfireSpritesheetCtx, x, 0, simulatedTimestamp);
            }
            console.log("Spritesheet de fogueira gerado.");
        }

        function generateTorchSpritesheet() {
            const NUM_FRAMES = 8;
            torchSpritesheetCanvas.width = TILE_SIZE * NUM_FRAMES;
            torchSpritesheetCanvas.height = TILE_SIZE;
            const frameDuration = 150; // Dura√ß√£o simulada para capturar a anima√ß√£o

            for (let i = 0; i < NUM_FRAMES; i++) {
                const x = i * TILE_SIZE;
                const simulatedTimestamp = i * frameDuration;
                // A fun√ß√£o drawTorch desenha relativo ao x,y que passamos
                drawTorch(torchSpritesheetCtx, x, 0, simulatedTimestamp);
            }
            console.log("Spritesheet de tocha gerado.");
        }

        // --- Inicializa√ß√£o ---
        function init() {
            backpackIcon = document.getElementById('backpackIcon');
            if (!backpackIcon) { console.error("√çcone da mochila n√£o encontrado!"); return; }
            timeRangeSlider = document.getElementById('timeRangeSlider');
            if (!timeRangeSlider) { console.error("Slider de tempo n√£o encontrado!"); return; }
            itemTooltip = document.getElementById('itemTooltip');
            if (!itemTooltip) { console.error("Elemento do tooltip n√£o encontrado!"); return; }

            loadGame();
            generateWaterSpritesheet();
            generateCampfireSpritesheet();
            generateTorchSpritesheet();
            preRenderMap();
            updateHotbarUI();
            startGrowthTimer();

            // Loop do Rel√≥gio
            updateGameTime(); drawGameClock(); updateNightOverlay();
            setInterval(() => { updateGameTime(); drawGameClock(); updateNightOverlay(); }, 1000);
            setInterval(saveGame, 30000); // Salva o jogo a cada 30 segundos

            // Listener de clique do √çCONE da Mochila
            backpackIcon.addEventListener('click', () => { console.log("Clique no √≠cone da mochila"); toggleBackpack(); });

            // Listeners da HOTBAR
            hotbarElement.querySelectorAll('.slot').forEach(slotElement => {
                slotElement.addEventListener('click', handleHotbarSlotClick);
                slotElement.addEventListener('dragstart', handleDragStart);
                slotElement.addEventListener('dragover', handleDragOver);
                slotElement.addEventListener('dragleave', handleDragLeave);
                slotElement.addEventListener('drop', handleDrop);
                slotElement.addEventListener('dragend', handleDragEnd);
                // Adiciona listeners para o tooltip
                slotElement.addEventListener('mouseover', showTooltip);
                slotElement.addEventListener('mouseout', hideTooltip);
            });

            // Listener do Slider de Tempo
            timeRangeSlider.addEventListener('input', (e) => {
                const targetHour = parseInt(e.target.value, 10);
                const n = new Date();
                const currentRealHour = n.getHours();
                // Calcula o offset necess√°rio para que a hora do jogo seja a hora alvo
                gameTimeOffset = (targetHour - currentRealHour + 24) % 24;
                updateGameTime();
                drawGameClock();
                updateNightOverlay();
            });

            // Adiciona Listeners de Toque ao Canvas
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false }); // Trata cancelamento como touchend


            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('DOMContentLoaded', init);


    </script>
</body>
</html>
