<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Added user-scalable=no -->
    <title>Pixel Farm Game</title>
    <style>
        body {
            font-family: 'Consolas', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            color: white;
            overflow: hidden;
            touch-action: none; /* Prevent default touch actions like scroll/zoom */
        }

        h1 {
            margin-bottom: 15px;
            font-weight: normal;
        }

        p {
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
            text-align: center; /* Center instructions */
        }

        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;

            background-color: #000;
            border: 2px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(150, 150, 255, 0.5),
                        inset 0 0 10px rgba(0, 0, 0, 0.5);
            padding: 2px;
            overflow: hidden;
        }

        canvas, #nightOverlay, #lightCanvas {
            position: absolute;
            top: 2px;
            left: 2px;
            image-rendering: pixelated;
            width: calc(100% - 4px);
            height: calc(100% - 4px);
            border-radius: 8px;
        }
        
        /* --- Cursores Customizados --- */
        #mouseIcon {
            position: absolute;
            width: 32px;
            height: 32px;
            pointer-events: none; /* O ícone não interfere com os cliques */
            z-index: 110; /* Acima de tudo */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: none; /* Começa escondido */
        }
        /* Define os ícones como background-image para o div #mouseIcon */
        #mouseIcon.cursor-walk { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="white" style="filter: drop-shadow(0 0 2px black);"><path d="M15.5 3.5a1.5 1.5 0 0 1 1.5 1.5v8a1.5 1.5 0 0 1-1.5 1.5h-4a1.5 1.5 0 0 1-1.5-1.5v-8a1.5 1.5 0 0 1 1.5-1.5h4zm-8 6a1.5 1.5 0 0 1 1.5 1.5v8a1.5 1.5 0 0 1-1.5 1.5h-4a1.5 1.5 0 0 1-1.5-1.5v-8a1.5 1.5 0 0 1 1.5-1.5h4z"/></svg>'); }
        #mouseIcon.cursor-action { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 0 2px black);"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>'); }
        #mouseIcon.cursor-invalid { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 0 2px black);"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>'); }

        #gameContainer > #itemTooltip { position: absolute; } /* Override if needed */

        #nightOverlay {
            background-color: #000033;
            opacity: 0;
            z-index: 5;
            pointer-events: none;
            transition: opacity 1s linear;
        }

        #lightCanvas {
            z-index: 6;
            pointer-events: none;
        }

        /* --- Container da Hotbar e Ícone da Mochila --- */
        #bottomUIContainer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: flex-end; /* Alinha o ícone e a hotbar na base */
            gap: 8px; /* Espaço entre o ícone e a hotbar */
            z-index: 10;
        }

        /* Ícone da Mochila */
        #backpackIcon {
            width: 45px;
            height: 45px;
            background-color: rgba(68, 68, 68, 0.8); /* #444 com alpha */
            border: 2px solid #888;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px; /* Tamanho do emoji */
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
        }
        #backpackIcon:hover {
            background-color: rgba(102, 102, 102, 0.9); /* #666 com alpha */
            border-color: #aaa;
        }

        #sideMenuIcons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Ícone de Construção */
        #constructionIcon {
            width: 45px;
            height: 45px;
            background-color: rgba(68, 68, 68, 0.8);
            border: 2px solid #888;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            user-select: none;
        }
        #constructionIcon.active, #constructionIcon:hover {
            background-color: rgba(102, 102, 102, 0.9);
            border-color: #FFD700;
        }

        /* Barra de Atalhos (Hotbar) */
        #hotbar {
            /* position, bottom, left, transform removidos (agora controlados pelo container) */
            display: flex;
            gap: 3px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            padding: 5px;
            border-radius: 8px;
            /* z-index removido (controlado pelo container) */
        }

        /* --- Estilo Geral do Slot (usado por Hotbar e Mochila) --- */
        .slot {
            width: 45px;
            height: 45px;
            border: 2px solid #888;
            background-color: #444;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: white;
            position: relative;
            cursor: pointer;
            user-select: none;
             transition: transform 0.1s ease-out, opacity 0.1s ease-out; /* Para feedback visual ao arrastar */
        }
        /* Estilo para quando um slot está sendo arrastado */
        .slot.dragging {
            opacity: 0.5;
            transform: scale(0.9);
        }
        /* Estilo para quando o mouse está sobre um slot válido para soltar */
        .slot.drag-over {
            border-color: #FFD700; /* Dourado */
            background-color: #555;
        }


        /* Destaque do slot ativo na hotbar */
        #hotbar .slot.active {
            background-color: #666;
            border-color: #FFF;
            box-shadow: 0 0 8px #FFF;
        }

        /* --- Container da Mochila --- */
        #backpackContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(40, 40, 40, 0.95); /* Slightly less transparent */
            border: 3px solid #666;
            border-radius: 10px;
            padding: 15px;
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        #backpackTitle {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #eee;
        }

        #backpackGrid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 8px;
        }

        #backpackGrid .slot {
             width: 50px;
             height: 50px;
             font-size: 10px;
        }

        #backpackGrid .slot.selected-for-assignment {
             border-color: #FFD700;
             box-shadow: 0 0 8px #FFD700;
         }

        #constructionGrid .slot.selected-for-assignment {
            border-color: #FFD700;
            box-shadow: 0 0 8px #FFD700;
        }

        /* --- Container de Construção --- */
        #constructionContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background-color: rgba(40, 40, 40, 0.95);
            border: 3px solid #FFD700; /* Borda dourada para diferenciar */
            border-radius: 10px;
            padding: 15px;
            z-index: 20;
            display: none; /* Começa escondido */
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        #floorSelector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
            width: 100%;
            background-color: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 5px;
        }
        #floorSelector button {
            background: #555;
            border: 1px solid #888;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            padding: 2px 8px;
        }
        #floorSelector button:hover { background: #777; }
        #floorSelector span { font-weight: bold; }

        #constructionTitle {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #eee;
        }
        #constructionGrid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 8px;
        }
        #constructionGrid .slot {
            width: 50px;
            height: 50px;
            font-size: 10px;
        }

        .slot-name {
            font-weight: bold;
            font-size: 10px;
            text-shadow: 1px 1px #000;
            pointer-events: none;
        }

        .slot-count {
            margin-top: 2px;
            font-size: 12px;
            color: #FFD700;
            font-weight: bold;
            pointer-events: none;
        }

        .slot-sub-action {
            font-size: 9px;
            color: #B2DFDB; /* Ciano claro */
            font-style: italic;
            margin-top: 1px;
            pointer-events: none;
        }

        #hotbar .slot-key {
            position: absolute;
            top: 1px;
            left: 2px;
            font-size: 9px;
            color: #AAA;
            font-weight: bold;
            pointer-events: none;
        }

        #gameClock {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            padding: 5px 10px 5px 30px;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px #000;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .time-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: transparent;
            flex-shrink: 0;
        }

        #gameClock span {
            line-height: 1;
        }

        /* --- Container do Slider de Tempo --- */
        #timeControlContainer {
            display: flex;
            align-items: center;
            gap: 10px;
             margin-top: 5px;
        }

        #timeControlContainer label {
            font-size: 0.9em;
        }

        #timeRangeSlider {
            width: 150px;
            cursor: pointer;
        }

        /* Estilos para o botão antigo, podem ser removidos ou adaptados */
        #timeToggleButton:hover { /* Mantido caso queira reutilizar o ID */
             background-color: #777;
        }

        /* --- Tooltip de Descrição do Item --- */
        #itemTooltip {
            position: absolute; /* Posição relativa ao gameContainer */
            display: none;   /* Começa escondido */
            background-color: rgba(20, 20, 20, 0.9);
            border: 1px solid #999;
            border-radius: 5px;
            padding: 8px 12px;
            color: #E0E0E0;
            font-size: 0.9em;
            max-width: 220px;
            z-index: 100; /* Fica em cima de tudo */
            pointer-events: none; /* Impede que o tooltip intercepte eventos do mouse */
            text-align: left;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.6);
        }

        /* --- Menu de Contexto do Item --- */
        #contextMenu {
            position: absolute;
            display: none;
            background-color: rgba(40, 40, 40, 0.98);
            border: 1px solid #aaa;
            border-radius: 5px;
            padding: 5px;
            z-index: 120;
            box-shadow: 0 4px 12px rgba(0,0,0,0.7);
        }
        .context-menu-item {
            padding: 8px 15px;
            color: #ddd;
            cursor: pointer;
            border-radius: 3px;
            white-space: nowrap;
        }
        .context-menu-item:hover {
            background-color: #555;
            color: white;
        }

    </style>
</head>
<body>
    <h1>Mini Fazenda Pixelada</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas">
            Seu navegador não suporta o elemento Canvas.
        </canvas>

        <div id="itemTooltip"></div>
        <div id="contextMenu"></div>
        <div id="mouseIcon"></div>

        <div id="nightOverlay"></div>
        <canvas id="lightCanvas"></canvas>
        <div id="gameClock">
            <canvas id="timeIconCanvas" class="time-icon" width="20" height="20"></canvas>
            <span>00:00</span>
        </div>

        <div id="constructionContainer">
            <div id="constructionTitle">Inventário de Construção</div>
            <div id="floorSelector">
                <button id="floorDownBtn">🔽</button>
                <span id="floorLabel">Andar: 0</span>
                <button id="floorUpBtn">🔼</button>
            </div>
            <div id="constructionGrid">
                <!-- Slots de construção gerados pelo JS -->
            </div>
            <p style="font-size: 0.8em; margin-top: 10px; color: #ccc;">Clique em um item e depois em um atalho (1-0) para atribuir.</p>
        </div>

        <div id="backpackContainer">
            <div id="backpackTitle">Mochila</div>
            <div id="backpackGrid">
                <!-- Slots da mochila gerados pelo JS -->
            </div>
             <p style="font-size: 0.8em; margin-top: 10px; color: #ccc;">Clique em um item e depois em um atalho (1-0) para atribuir.</p>
        </div>

        <div id="bottomUIContainer">
            <div id="sideMenuIcons">
                <div id="constructionIcon">🔨</div>
                <div id="backpackIcon">🎒</div>
            </div>
            <div id="hotbar">
                <div class="slot" data-hotbar-index="0" draggable="true"> <span class="slot-key">1</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="1" draggable="true"> <span class="slot-key">2</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="2" draggable="true"> <span class="slot-key">3</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="3" draggable="true"> <span class="slot-key">4</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="4" draggable="true"> <span class="slot-key">5</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="5" draggable="true"> <span class="slot-key">6</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="6" draggable="true"> <span class="slot-key">7</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="7" draggable="true"> <span class="slot-key">8</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="8" draggable="true"> <span class="slot-key">9</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
                <div class="slot" data-hotbar-index="9" draggable="true"> <span class="slot-key">0</span> <span class="slot-name"></span> <span class="slot-sub-action"></span> <span class="slot-count"></span> </div>
            </div>
        </div>


    </div>
    <!-- Instruções Atualizadas -->
    <p>Setas/Toque: Mover. Espaço/Toque à frente: Usar. 1-0: Atalhos. B/🎒: Mochila.</p>
    <!-- Controle de Tempo Atualizado -->
    <div id="timeControlContainer">
        <label for="timeRangeSlider">Hora (Teste):</label>
        <input type="range" id="timeRangeSlider" min="0" max="23" step="1" value="0">
    </div>

    <script>
        // --- Configurações Iniciais ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameClockSpan = document.querySelector('#gameClock span');
        const timeIconCanvas = document.getElementById('timeIconCanvas');
        const timeIconCtx = timeIconCanvas.getContext('2d');
        const nightOverlay = document.getElementById('nightOverlay');
        const lightCanvas = document.getElementById('lightCanvas');
        const lightCtx = lightCanvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const backpackContainer = document.getElementById('backpackContainer');
        const backpackGrid = document.getElementById('backpackGrid');
        const hotbarElement = document.getElementById('hotbar');
        const constructionGrid = document.getElementById('constructionGrid');
        let constructionContainer = document.getElementById('constructionContainer');
        let backpackIcon = null; // Definido dentro de init()
        let constructionIcon = null; // Definido dentro de init()
        let timeRangeSlider = null; // Definido dentro de init()
        let itemTooltip = null; // Definido dentro de init()
        let mouseIcon = null; // Definido dentro de init()
        let contextMenu = null; // Definido dentro de init()
        let floorSelectorLabel = null;
        let floorUpBtn = null;
        let floorDownBtn = null;


        ctx.imageSmoothingEnabled = false;
        timeIconCtx.imageSmoothingEnabled = false;
        lightCtx.imageSmoothingEnabled = false;

        const zoomLevel = 1;

        canvas.width = (640 - 4) / zoomLevel;
        canvas.height = (480 - 4) / zoomLevel;
        lightCanvas.width = canvas.width;
        lightCanvas.height = canvas.height;

        // --- Configurações do Jogo ---
        const TILE_SIZE = 32;
        const GROWTH_TIME_SPROUT = 60000;
        const GROWTH_TIME_PLANT = 120000;
        const GROWTH_TIME_HARVEST = 180000;
        const TOOL_ANIM_DURATION = 150;
        const BACKPACK_SIZE = 20;
        const HOTBAR_SIZE = 10;
        const TOUCH_MOVE_THRESHOLD = TILE_SIZE * 0.5; // Distância mínima para registrar toque como movimento
        const TAP_TIME_THRESHOLD = 300; // Tempo máximo (ms) para um toque ser considerado 'tap' para ação (aumentado um pouco)

        // --- Estado do Jogo ---
        let player = {
            x: 34 * TILE_SIZE, y: 33 * TILE_SIZE, width: 20, height: 28,
            colorHead: '#FFDAB9', colorBody: '#007BFF', colorLegs: '#0056B3',
            speed: 2, isMoving: false, targetX: 34 * TILE_SIZE, targetY: 33 * TILE_SIZE, currentFloor: 0,
            path: [], // Para o movimento point-and-click
            walkBob: 0, walkBobSpeed: 0.15, isUsingTool: false, toolAnimStart: 0, toolTarget: null, toolSubAction: null,
            lastMoveDir: { dx: 0, dy: 1 }
        };

        let camera = { x: 0, y: 0 };

        // --- Geração do Mapa ---
        const MAP_WIDTH_TILES = 50;
        const MAP_HEIGHT_TILES = 50;
        const BORDER_SIZE = 5;

        // Função para gerar o layout do mundo uma única vez
        function createWorldLayout() {
            // 0=Grama, 1=Terra, 2=Arado, 3=Água, 4=Semente, 5=Muda, 6=Planta, 7=Colheita, 8=Piso, 9=Argila
            const baseLayout = [
                [0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,3,3,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,3,3,0,0,0,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,3,3,0,0,0,0,0,1,2,1,1,2,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,3,3,0,3,0,0,1,2,1,1,2,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,3,3,3,3,0,0,1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,3,3,3,3,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,3,3,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],

            ];
            const baseWidth = baseLayout[0].length;
            const baseHeight = baseLayout.length;
            const offsetX = Math.floor((MAP_WIDTH_TILES - baseWidth) / 2);
            const offsetY = Math.floor((MAP_HEIGHT_TILES - baseHeight) / 2);

            const finalLayout = [];
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                const row = [];
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    if (x < BORDER_SIZE || x >= MAP_WIDTH_TILES - BORDER_SIZE || y < BORDER_SIZE || y >= MAP_HEIGHT_TILES - BORDER_SIZE) {
                        row.push(3); // Borda de água
                    } else {
                        const relativeX = x - offsetX;
                        const relativeY = y - offsetY;
                        if (relativeY >= 0 && relativeY < baseHeight && relativeX >= 0 && relativeX < baseWidth) {
                            row.push(baseLayout[relativeY][relativeX]); // Cola o mapa base
                        } else {
                            // Adiciona vegetação aleatória para dar vida ao mapa
                            const rand = Math.random();
                            if (rand < 0.015) { // 1.5% de chance
                                row.push(12); // Flor Vermelha
                            } else if (rand < 0.03) { // 1.5% de chance
                                row.push(13); // Flor Amarela
                            } else if (rand < 0.05) { // 2% de chance
                                row.push(14); // Arbusto Pequeno
                            } else {
                                row.push(0); // Grama no resto
                            }
                        }
                    }
                }
                finalLayout.push(row);
            }
            return finalLayout;
        }

        const WORLD_LAYOUT = createWorldLayout();
        // O mapa do jogo é uma cópia profunda do layout, para que possa ser modificado.
        // let map = JSON.parse(JSON.stringify(WORLD_LAYOUT)); // Movido para a estrutura worldData

        const MAP_WIDTH_PX = MAP_WIDTH_TILES * TILE_SIZE; const MAP_HEIGHT_PX = MAP_HEIGHT_TILES * TILE_SIZE;

        // let plantGrowthData = {}; // Movido para a estrutura worldData

        // type: 0=Rocha, 1=Árvore, 2=Fogueira, 3=Tocha
        // As coordenadas agora são ABSOLUTAS, pré-calculadas.
        const initialMapObjects = [
            // Árvores
            { type: 1, x: 12, y: 16 }, { type: 1, x: 16, y: 23 }, { type: 1, x: 18, y: 26 }, { type: 1, x: 30, y: 24 }, { type: 1, x: 32, y: 28 }, { type: 1, x: 34, y: 21 },
            { type: 1, x: 14, y: 31 }, { type: 1, x: 22, y: 36 }, { type: 1, x: 27, y: 41 }, { type: 1, x: 34, y: 38 }, { type: 1, x: 17, y: 38 }, // Movida árvore de (35,36)
            // Rochas
            { type: 0, x: 10, y: 19 }, { type: 0, x: 17, y: 24 }, { type: 0, x: 31, y: 22 }, { type: 0, x: 33, y: 27 }, { type: 0, x: 29, y: 29 },
            { type: 0, x: 20, y: 32 }, { type: 0, x: 24, y: 38 }, { type: 0, x: 13, y: 36 }, { type: 0, x: 28, y: 34 }, { type: 0, x: 32, y: 42 }, { type: 0, x: 34, y: 29 }, // Movida rocha de (35,30)
            // Fogueiras e Tochas
            { type: 2, x: 25, y: 28 }, { type: 2, x: 20, y: 34 },
            { type: 3, x: 28, y: 17 }, { type: 3, x: 13, y: 31 }, { type: 3, x: 35, y: 17 }, { type: 3, x: 24, y: 40 },
        ];

        // Adiciona escadas para o sistema de andares
        // Escada para cima no térreo
        initialMapObjects.push({ type: 9, x: 19, y: 14, targetFloor: 1, targetX: 19, targetY: 13 });
        // Escada para baixo no primeiro andar (será adicionada ao array de objetos do andar 1)
        const floor1Objects = [
            { type: 10, x: 19, y: 13, targetFloor: 0, targetX: 19, targetY: 14 },
            // Adiciona algumas árvores no andar de cima para teste visual
            { type: 1, x: 16, y: 11 }, { type: 1, x: 22, y: 12 }, { type: 1, x: 18, y: 13 },
            { type: 1, x: 23, y: 10 }
        ];

        // --- Adiciona a base da "montanha" para o sistema de andares ---
        const mountainStartX = 15;
        const mountainStartY = 10;
        const mountainWidth = 10;
        const mountainHeight = 5;
        for (let y = 0; y < mountainHeight; y++) {
            for (let x = 0; x < mountainWidth; x++) {
                initialMapObjects.push({ type: 8, x: mountainStartX + x, y: mountainStartY + y }); // type 8 = Parede de Montanha
            }
        }

        // Floresta Densa (coordenadas absolutas)
        for (let y = 5; y <= 13; y++) { // Ajustado para não sobrepor a cerca
            for (let x = 30; x <= 38; x++) {
                initialMapObjects.push({ type: 1, x: x + 12, y: y + 16 });
            }
        }

        // Campo de Rochas (coordenadas absolutas)
        for (let y = 30; y <= 38; y++) {
            for (let x = 5; x <= 15; x++) {
                initialMapObjects.push({ type: 0, x: x + 12, y: y + 16 });
            }
        }

        // --- Adiciona o novo cercado para as ovelhas no canto sudeste ---
        const newFenceStartX = 35;
        const newFenceStartY = 30;
        const newFenceEndX = 43;
        const newFenceEndY = 37;
        const newGateY = 33; // Posição Y da porteira na parede esquerda

        for (let x = newFenceStartX; x <= newFenceEndX; x++) {
            initialMapObjects.push({ type: 4, x: x, y: newFenceStartY });
            initialMapObjects.push({ type: 4, x: x, y: newFenceEndY });
        }
        for (let y = newFenceStartY + 1; y < newFenceEndY; y++) {
            if (y < newGateY || y > newGateY + 1) {
                initialMapObjects.push({ type: 4, x: newFenceStartX, y: y });
            }
            initialMapObjects.push({ type: 4, x: newFenceEndX, y: y });
        }
        initialMapObjects.push({ type: 7, x: newFenceStartX, y: newGateY, orientation: 'horizontal', isOpen: false });
        initialMapObjects.push({ type: 7, x: newFenceStartX, y: newGateY + 1, orientation: 'horizontal', isOpen: false });

        // --- Validação de Posição de Objetos Iniciais ---
        const validatedInitialObjects = initialMapObjects.filter(obj => {
            if (obj.y < 0 || obj.y >= MAP_HEIGHT_TILES || obj.x < 0 || obj.x >= MAP_WIDTH_TILES) return false;
            const tileId = WORLD_LAYOUT[obj.y][obj.x];
            if (tileId === 3) { // Remove objetos que estão na água (tile 3)
                console.warn(`Objeto inicial (tipo ${obj.type}) em [${obj.x}, ${obj.y}] removido por estar na água.`);
                return false;
            }
            return true;
        });

        // --- Animais Iniciais ---
        const initialAnimals = [
            { type: 'sheep', gender: 'male', age: 100, x: 36 * TILE_SIZE, y: 32 * TILE_SIZE, state: 'idle', woolLevel: 0, hunger: 0, path: [], isMoving: false, speed: 1, walkBob: 0, walkBobSpeed: 0.1, lastMoveDir: { dx: 0, dy: 1 }, stateTimer: 0, timeAtMaxHunger: 0 },
            { type: 'sheep', gender: 'female', age: 100, x: 38 * TILE_SIZE, y: 34 * TILE_SIZE, state: 'idle', woolLevel: 20, hunger: 0, path: [], isMoving: false, speed: 1, walkBob: 0, walkBobSpeed: 0.1, lastMoveDir: { dx: 0, dy: 1 }, stateTimer: 0, timeAtMaxHunger: 0 },
            { type: 'sheep', gender: 'female', age: 100, x: 40 * TILE_SIZE, y: 33 * TILE_SIZE, state: 'idle', woolLevel: 50, hunger: 0, path: [], isMoving: false, speed: 1, walkBob: 0, walkBobSpeed: 0.1, lastMoveDir: { dx: 0, dy: 1 }, stateTimer: 0, timeAtMaxHunger: 0 },
        ];

        // --- Estrutura de Dados do Mundo ---
        let worldData = [];

        function createNewFloorData(layout, objects) {
            // Garante que o canvas de pré-renderização seja criado corretamente
            const preRenderedCanvas = document.createElement('canvas');
            preRenderedCanvas.width = MAP_WIDTH_PX;
            preRenderedCanvas.height = MAP_HEIGHT_PX;
            const preRenderedCtx = preRenderedCanvas.getContext('2d');
            preRenderedCtx.imageSmoothingEnabled = false;

            return {
                map: JSON.parse(JSON.stringify(layout)),
                mapObjects: JSON.parse(JSON.stringify(objects)),
                plantGrowthData: {},
                animals: [], // Adicionado para cada andar
                preRenderedMapCanvas: preRenderedCanvas,
                preRenderedMapCtx: preRenderedCtx
            };
        }

        function createFloor1Layout() {
            const layout = Array(MAP_HEIGHT_TILES).fill(0).map(() => Array(MAP_WIDTH_TILES).fill(10)); // 10 = Vazio
            for (let y = mountainStartY; y < mountainStartY + mountainHeight; y++) {
                for (let x = mountainStartX; x < mountainStartX + mountainWidth; x++) {
                    layout[y][x] = 0; // Grama no topo da montanha
                }
            }
            return layout;
        }

        // Cria um andar completamente vazio
        function createEmptyFloorLayout() {
            return Array(MAP_HEIGHT_TILES).fill(0).map(() => Array(MAP_WIDTH_TILES).fill(10)); // 10 = Vazio
        }

        // --- Estrutura de Inventário ---
        let backpackInventory = new Array(BACKPACK_SIZE).fill(null);
        let hotbarMapping = new Array(HOTBAR_SIZE).fill(-1);
        let activeHotbarSlot = 0;
        let isBackpackOpen = false;
        let selectedBackpackIndex = -1;
        let mouseHoverTile = { x: null, y: null };
        let isConstructionInventoryOpen = false;
        let selectedConstructionIndex = -1; // Para o novo inventário de construção
        let isConstructionModeActive = false;
        let constructionTargetFloor = 0;

        // Mapeamentos e slots ativos para cada modo
        let constructionHotbarMapping = new Array(HOTBAR_SIZE).fill(-1);
        let activeConstructionHotbarSlot = 0;


        const ITEMS = {
            'hoe': { id: 'hoe', name: 'Enxada', description: '<strong>Enxada</strong><br>Prepara a terra para o plantio.', category: 'ferramenta', stackable: false },
            'seed_tomato': { id: 'seed_tomato', name: 'Semente', description: '<strong>Semente</strong><br>Plante em solo arado para cultivar tomates.', category: 'material', stackable: true, actions: [ { label: "Plantar Tomate", action: "log", value: "Ainda só temos um tipo de semente." }, { label: "Plantar Milho", action: "log", value: "Semente de milho não implementada." }, { label: "Plantar Árvore", action: "log", value: "Semente de árvore não implementada." } ] },
            'tomato': { id: 'tomato', name: 'Colheita', description: '<strong>Colheita</strong><br>O fruto do seu trabalho. Um tomate suculento.', category: 'material', stackable: true },
            'shovel': { id: 'shovel', name: 'Pá', description: '<strong>Pá</strong><br>Coleta argila, remove cercas, pisos e plantações. Permite cavar ou aterrar água.', category: 'ferramenta', stackable: false },
            'watering_can': { id: 'watering_can', name: 'Regador', description: '<strong>Regador</strong><br>Acelera o crescimento das plantas.', category: 'ferramenta', stackable: false },
            'axe': { id: 'axe', name: 'Machado', description: '<strong>Machado</strong><br>Corta árvores para obter madeira.', category: 'ferramenta', stackable: false },
            'pickaxe': { id: 'pickaxe', name: 'Picareta', description: '<strong>Picareta</strong><br>Quebra pedras para obter minerais.', category: 'ferramenta', stackable: false },
            'stone': { id: 'stone', name: 'Pedra', description: '<strong>Pedra</strong><br>Material de construção básico.', category: 'material_construcao', stackable: true },
            'wood': { id: 'wood', name: 'Madeira', description: '<strong>Madeira</strong><br>Material de construção básico.', category: 'material_construcao', stackable: true },
            'clay': { id: 'clay', name: 'Argila', description: '<strong>Argila</strong><br>Material úmido, pode ser usado para criar itens mais resistentes.', category: 'material_construcao', stackable: true },
            'fence': { id: 'fence', name: 'Cerca', description: '<strong>Cerca</strong><br>Uma cerca pré-fabricada.', category: 'construcao', stackable: true },
            'wall': { id: 'wall', name: 'Muro', description: '<strong>Muro</strong><br>Um muro de tijolos resistente.', category: 'construcao', stackable: true },
            'door': { id: 'door', name: 'Porta', description: '<strong>Porta</strong><br>Uma porta de madeira.', category: 'construcao', stackable: true },
            'gate': { id: 'gate', name: 'Porteira', description: '<strong>Porteira</strong><br>Uma porteira de fazenda.', category: 'construcao', stackable: true },
            'roof': { id: 'roof', name: 'Telhado', description: '<strong>Telhado</strong><br>Cobre as suas construções. Custa 1 Argila.', category: 'construcao', stackable: true },
            'shears': { id: 'shears', name: 'Tesoura', description: '<strong>Tesoura de Tosquia</strong><br>Use para tosquiar ovelhas e obter lã.', category: 'ferramenta', stackable: false },
            'wool': { id: 'wool', name: 'Lã', description: '<strong>Lã</strong><br>Lã macia de ovelha. Pode ser usada para artesanato.', category: 'material', stackable: true },
            'construction_tool': { id: 'construction_tool', name: 'Construção', description: '<strong>Construção</strong><br>Permite construir e remover estruturas.', category: 'ferramenta', stackable: false, actions: [
                    { label: "Mudar para modo 'Pegar'", action: "set_sub_action", value: "pickup_mode" },
                    { label: "Construir Escada", action: "set_sub_action", value: "build_stairs" },
                    { label: "Construir Porta", action: "set_sub_action", value: "build_door" },
                    { label: "Construir Porteira", action: "set_sub_action", value: "build_gate" },
                    { label: "Construir Piso", action: "set_sub_action", value: "build_floor" },
                    { label: "Construir Muro", action: "set_sub_action", value: "build_wall" },
                    { label: "Construir Telhado", action: "set_sub_action", value: "build_roof" },
                    { label: "Construir Cerca", action: "set_sub_action", value: "build_fence" }
                ]
            }
        };

        let activeAnimations = [];

        let gameHour = 0; let gameMinute = 0; let gameTimeOffset = 0;
        const GAME_MINUTES_PER_DAY = 1440; const REAL_SECONDS_PER_GAME_DAY = 3600;

        // --- Variáveis de Toque ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let touchHoldTimeout = null; // Timeout para detectar "hold"
        let isHolding = false; // Flag para indicar se está segurando para mover
        let isContextMenuOpen = false;

        const waterSpritesheetCanvas = document.createElement('canvas');
        const waterSpritesheetCtx = waterSpritesheetCanvas.getContext('2d');
        waterSpritesheetCtx.imageSmoothingEnabled = false;

        const campfireSpritesheetCanvas = document.createElement('canvas');
        const campfireSpritesheetCtx = campfireSpritesheetCanvas.getContext('2d');
        campfireSpritesheetCtx.imageSmoothingEnabled = false;

        const torchSpritesheetCanvas = document.createElement('canvas');
        const torchSpritesheetCtx = torchSpritesheetCanvas.getContext('2d');
        torchSpritesheetCtx.imageSmoothingEnabled = false;

        // --- Funções de Desenho ---
        function drawGrassTile(ctx, x, y, size) { ctx.fillStyle = '#558B2F'; ctx.fillRect(x, y, size, size); ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; const pS = 4; for (let ty=0; ty<size; ty+=pS*2){ for(let tx=0; tx<size; tx+=pS*2){ ctx.fillRect(x+tx, y+ty, pS, pS); ctx.fillRect(x+tx+pS, y+ty+pS, pS, pS); } } }
        function drawEarthTile(ctx, x, y, size) { ctx.fillStyle = '#8D6E63'; ctx.fillRect(x, y, size, size); ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(x+5, y+10, 4, 4); ctx.fillRect(x+15, y+25, 4, 4); ctx.fillRect(x+22, y+8, 4, 4); ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(x+8, y+20, 3, 3); ctx.fillRect(x+18, y+5, 3, 3); ctx.fillRect(x+25, y+15, 3, 3); }
        function drawPlowedTile(ctx, x, y, size) { ctx.fillStyle = '#5D4037'; ctx.fillRect(x, y, size, size); ctx.fillStyle = '#A1887F'; const fH = 4; const s = 10; for(let fy=2; fy<size; fy+=s){ ctx.fillRect(x, y+fy, size, fH); } }
        function drawWaterTile(ctx, x, y, size) { ctx.fillStyle = '#1976D2'; ctx.fillRect(x, y, size, size); ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.fillRect(x+5, y+8, 10, 4); ctx.fillRect(x+18, y+20, 8, 4); ctx.fillRect(x+10, y+15, 6, 3); }
        function drawSeedTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#A1887F'; ctx.fillRect(x+8, y+6, 3, 3); ctx.fillRect(x+20, y+16, 3, 3); ctx.fillRect(x+12, y+26, 3, 3); }
        function drawSproutTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#8BC34A'; ctx.fillRect(x+13, y+10, 6, 8); ctx.fillRect(x+15, y+8, 2, 4); }
        function drawPlantTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#4CAF50'; ctx.fillRect(x+12, y+8, 8, 16); ctx.fillRect(x+8, y+12, 4, 8); ctx.fillRect(x+20, y+12, 4, 8); }
        function drawHarvestableTile(ctx, x, y, size) { drawPlowedTile(ctx, x, y, size); ctx.fillStyle = '#388E3C'; ctx.fillRect(x+10, y+5, 12, 22); ctx.fillRect(x+6, y+10, 4, 12); ctx.fillRect(x+22, y+10, 4, 12); ctx.fillStyle = '#E53935'; ctx.fillRect(x+14, y+14, 4, 4); ctx.fillRect(x+10, y+18, 4, 4); ctx.fillRect(x+18, y+18, 4, 4); }
        function drawRock(ctx, x_px, y_px) { ctx.fillStyle='#795548'; ctx.fillRect(x_px+4, y_px+10, 24, 18); ctx.fillStyle='#8D6E63'; ctx.fillRect(x_px+6, y_px+12, 20, 14); ctx.fillStyle='#5D4037'; ctx.fillRect(x_px+18, y_px+15, 6, 6); ctx.fillRect(x_px+8, y_px+20, 8, 8); }
        function drawTreeTrunk(ctx, x_px, y_px) { ctx.fillStyle='#5D4037'; ctx.fillRect(x_px+12, y_px+16, 8, TILE_SIZE-16); ctx.fillStyle='#795548'; ctx.fillRect(x_px+13, y_px+17, 6, TILE_SIZE-18); }
        function drawTreeCanopy(ctx, x_px, y_px) {
            const yT = y_px - TILE_SIZE * 1.5 + 8;
            const xC = x_px + TILE_SIZE / 2;
            
            // A lógica de opacidade só se aplica se não estivermos já em modo de transparência (para a pré-visualização)
            const isPreviewing = ctx.globalAlpha < 1.0;
            if (!isPreviewing) {
                // Verifica se o jogador está atrás da árvore
                const isPlayerBehind = player.y < y_px + TILE_SIZE && 
                                      player.y + player.height > y_px - TILE_SIZE && 
                                      player.x + player.width > x_px - TILE_SIZE && 
                                      player.x < x_px + TILE_SIZE * 2;
                // Define a opacidade baseada na posição do jogador
                ctx.globalAlpha = isPlayerBehind ? 0.3 : 1.0;
            }

            // Desenha a copa mais escura
            ctx.fillStyle = '#388E3C';
            ctx.beginPath();
            ctx.ellipse(xC, yT + TILE_SIZE * 0.8, TILE_SIZE * 1.1, TILE_SIZE * 0.9, 0, 0, Math.PI * 2);
            ctx.ellipse(xC - TILE_SIZE * 0.5, yT + TILE_SIZE * 1.2, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(xC + TILE_SIZE * 0.5, yT + TILE_SIZE * 1.2, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Desenha a copa mais clara
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.ellipse(xC, yT + TILE_SIZE * 0.7, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(xC - TILE_SIZE * 0.4, yT + TILE_SIZE * 1.0, TILE_SIZE * 0.6, TILE_SIZE * 0.5, 0, 0, Math.PI * 2);
            ctx.ellipse(xC + TILE_SIZE * 0.4, yT + TILE_SIZE * 1.0, TILE_SIZE * 0.6, TILE_SIZE * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Restaura a opacidade original apenas se a tivermos alterado
            if (!isPreviewing) {
                ctx.globalAlpha = 1.0;
            }
        }
        function drawCampfire(ctx, x_px, y_px, timestamp) {
            // Logs
            ctx.fillStyle='#A1887F'; ctx.fillRect(x_px+10, y_px+20, 4, 6); ctx.fillRect(x_px+18, y_px+22, 4, 6); ctx.fillRect(x_px+14, y_px+24, 6, 4);
            ctx.fillStyle='#795548'; ctx.fillRect(x_px+12, y_px+21, 8, 2); ctx.fillRect(x_px+12, y_px+23, 8, 2);
            // Fogo mais vivo
            const fH=(Math.sin(timestamp*0.005)*0.1+0.9)*30;
            const fS1=Math.sin(timestamp*0.003)*1+3;
            const fS2=Math.sin(timestamp*0.0045)*0.8+0.5;
            const fS = fS1 + fS2; // Combina duas ondas para um pulso mais natural
            ctx.fillStyle=`hsl(${fH}, 100%, 50%)`; ctx.fillRect(x_px+14, y_px+16-fS, 4, 4+fS);
            ctx.fillStyle=`hsl(${fH+10}, 100%, 60%)`; ctx.fillRect(x_px+12, y_px+18-fS/2, 4, 4+fS/2); ctx.fillRect(x_px+18, y_px+18-fS/2, 4, 4+fS/2);
            // Fumaça mais densa
            for (let i = 0; i < 5; i++) {
                const timeOffset = timestamp + i * 500;
                const sO = (timeOffset * 0.001) % (TILE_SIZE / 1.5);
                const opacity = Math.max(0, 0.4 - (sO / (TILE_SIZE / 1.5)) * 0.4);
                const size = 2 + (i % 2);
                const drift = Math.sin(timeOffset * 0.0005 + i) * 3;
                ctx.fillStyle=`rgba(180,180,180, ${opacity})`;
                ctx.fillRect(x_px + 15 + drift, y_px + 12 - sO * (1 + i * 0.1), size, size);
            }
        }
        function drawTorch(ctx, x_px, y_px, timestamp) { const tX=x_px+TILE_SIZE/2-2; const tY=y_px+TILE_SIZE/2; ctx.fillStyle='#795548'; ctx.fillRect(tX, tY, 4, 10); ctx.fillStyle='#A0A0A0'; ctx.fillRect(tX-1, tY-2, 6, 2); const fH=(Math.sin(timestamp*0.007)*0.1+0.9)*30; const fS=Math.sin(timestamp*0.004)*0.5+1.5; ctx.fillStyle=`hsl(${fH}, 100%, 50%)`; ctx.fillRect(tX+1, tY-6-fS, 2, 4+fS); ctx.fillStyle=`hsl(${fH+10}, 100%, 60%)`; ctx.fillRect(tX, tY-4-fS/2, 4, 2+fS/2); }
        function drawFence(ctx, x_px, y_px, tileX, tileY, floor) {
            const floorData = worldData[floor];
            if (!floorData) return;
            const fenceObjects = floorData.mapObjects.filter(obj => obj.type === 4);

            const hasN = fenceObjects.some(o => o.x === tileX && o.y === tileY - 1);
            const hasS = fenceObjects.some(o => o.x === tileX && o.y === tileY + 1);
            const hasE = fenceObjects.some(o => o.x === tileX + 1 && o.y === tileY);
            const hasW = fenceObjects.some(o => o.x === tileX - 1 && o.y === tileY);

            const postColor = '#5D4037';
            const railColor = '#3E2723';

            // Desenha o poste central
            ctx.fillStyle = postColor;
            ctx.fillRect(x_px + 12, y_px + 12, 8, 8);

            // Desenha as barras de ligação com base nos vizinhos
            ctx.fillStyle = railColor;
            if (hasN) ctx.fillRect(x_px + 14, y_px, 4, 14);
            if (hasS) ctx.fillRect(x_px + 14, y_px + 16, 4, 16);
            if (hasW) ctx.fillRect(x_px, y_px + 14, 14, 4);
            if (hasE) ctx.fillRect(x_px + 16, y_px + 14, 16, 4);
        }
        function drawRedFlowerTile(ctx, x, y, size) {
            drawGrassTile(ctx, x, y, size); // Base de grama
            ctx.fillStyle = '#4CAF50'; // Caule
            ctx.fillRect(x + size / 2 - 1, y + size / 2, 2, 10);
            ctx.fillStyle = '#E53935'; // Pétalas vermelhas
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2 - 2, 5, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawYellowFlowerTile(ctx, x, y, size) {
            drawGrassTile(ctx, x, y, size); // Base de grama
            ctx.fillStyle = '#689F38'; // Caule
            ctx.fillRect(x + size / 2 - 1, y + size / 2 + 2, 2, 8);
            ctx.fillStyle = '#FFEB3B'; // Pétalas amarelas
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawSmallBushTile(ctx, x, y, size) {
            drawGrassTile(ctx, x, y, size); // Base de grama
            ctx.fillStyle = '#388E3C'; // Cor do arbusto
            ctx.beginPath();
            ctx.ellipse(x + size / 2, y + size * 0.7, size * 0.4, size * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawFloorTile(ctx, x, y, size) { // Sprite aprimorado
            const plankColor = '#A1887F'; // Um marrom médio para as tábuas
            const gapColor = '#795548';   // Um marrom mais escuro para os vãos
            const nailColor = '#5D4037';  // Cor dos pregos

            ctx.fillStyle = plankColor;
            ctx.fillRect(x, y, size, size);

            // Desenha os vãos horizontais e os pregos
            for (let i = 8; i < size; i += 8) {
                ctx.fillStyle = gapColor;
                ctx.fillRect(x, y + i - 1, size, 2); // Vão de 2px
                ctx.fillStyle = nailColor;
                ctx.fillRect(x + 4, y + i - 3, 2, 2); // Prego esquerdo
                ctx.fillRect(x + size - 6, y + i - 3, 2, 2); // Prego direito
            }
        }
        function drawDoor(ctx, x_px, y_px, orientation, isOpen) { // Sprite da porta aberta melhorado
            const frameColor = '#5D4037';
            const doorColor = '#8D6E63';
            const knobColor = '#FFC107';

            if (isOpen) {
                // Se estiver aberta, desenha apenas a porta como uma linha na lateral
                ctx.fillStyle = doorColor;
                if (orientation === 'vertical') {
                    ctx.fillRect(x_px, y_px, 4, TILE_SIZE); // Linha na esquerda
                } else { // horizontal
                    ctx.fillRect(x_px, y_px, TILE_SIZE, 4); // Linha em cima
                }
            } else {
                // Se estiver fechada, desenha a moldura e a porta
                ctx.fillStyle = frameColor;
                ctx.fillRect(x_px, y_px, TILE_SIZE, 4); // Top
                ctx.fillRect(x_px, y_px + TILE_SIZE - 4, TILE_SIZE, 4); // Bottom
                ctx.fillRect(x_px, y_px, 4, TILE_SIZE); // Left
                ctx.fillRect(x_px + TILE_SIZE - 4, y_px, 4, TILE_SIZE); // Right

                ctx.fillStyle = doorColor;
                ctx.fillRect(x_px + 4, y_px + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                ctx.fillStyle = knobColor;
                ctx.fillRect(x_px + TILE_SIZE - 10, y_px + 14, 3, 3); // Maçaneta
            }
        }
        function drawGate(ctx, x_px, y_px, orientation, isOpen) {
            const postColor = '#5D4037';
            const gateColor = '#8D2327';

            if (orientation === 'vertical') {
                ctx.fillStyle = postColor;
                ctx.fillRect(x_px + 4, y_px + 4, 4, 24); // Poste esquerdo
                ctx.fillRect(x_px + 24, y_px + 4, 4, 24); // Poste direito
                if (!isOpen) {
                    ctx.fillStyle = gateColor;
                    ctx.fillRect(x_px + 8, y_px + 8, 16, 4);
                    ctx.fillRect(x_px + 8, y_px + 18, 16, 4);
                }
            } else { // horizontal
                ctx.fillStyle = postColor;
                ctx.fillRect(x_px + 14, y_px, 4, 8); // Poste superior
                ctx.fillRect(x_px + 14, y_px + 24, 4, 8); // Poste inferior
                if (!isOpen) {
                    ctx.fillStyle = gateColor;
                    ctx.fillRect(x_px + 8, y_px + 8, 4, 16);
                    ctx.fillRect(x_px + 20, y_px + 8, 4, 16);
                }
            }
        }
        function drawWall(ctx, x_px, y_px) {
            const brickColor = '#c25b5b';  // Cor de tijolo avermelhada
            const mortarColor = '#a19a93'; // Cor da argamassa
            const brickHeight = 8;
            const brickWidth = 16;

            // Salva o estado do canvas e cria uma máscara de recorte para o tile
            ctx.save();
            ctx.beginPath();
            ctx.rect(x_px, y_px, TILE_SIZE, TILE_SIZE);
            ctx.clip();

            // Pinta o fundo com a cor da argamassa
            ctx.fillStyle = mortarColor;
            ctx.fillRect(x_px, y_px, TILE_SIZE, TILE_SIZE);

            ctx.fillStyle = brickColor;

            // Desenha as linhas de tijolos, garantindo que o padrão se repita
            for (let row = 0; row < TILE_SIZE / brickHeight; row++) {
                const y = y_px + row * brickHeight;
                // Desloca as linhas pares para criar o padrão de amarração
                const xOffset = (row % 2 === 0) ? 0 : -brickWidth / 2;
                for (let col = -1; col < TILE_SIZE / brickWidth + 1; col++) {
                    const x = x_px + col * brickWidth + xOffset;
                    ctx.fillRect(x, y, brickWidth - 1, brickHeight - 1);
                }
            }

            // Restaura o estado do canvas, removendo a máscara de recorte
            ctx.restore();
        }
        function drawSheep(ctx, animal) {
            const x = animal.x;
            const y = animal.y + Math.sin(animal.walkBob) * 2; // Bobbing motion
            const bodyColor = '#ECEFF1';
            const faceColor = '#37474F';
            const legColor = '#455A64';
            const hornColor = '#BCAAA4';
            const woolSize = animal.woolLevel >= 100 ? 2 : 0; // Lã extra
            const isAdult = animal.age >= 100;
            const scale = isAdult ? 1.0 : 0.7; // Filhotes são 70% do tamanho
            
            // Animação da cabeça a comer
            const headBob = animal.state === 'eating' ? Math.sin(animal.stateTimer * 0.1) * 4 + 4 : 0;

            ctx.save();
            // Centraliza o desenho e inverte se estiver a olhar para a esquerda
            ctx.translate(x + 16, y + 16 + (1 - scale) * 16); // Ajusta a posição Y para filhotes
            ctx.scale(scale, scale);

            if (animal.lastMoveDir.dx < 0) {
                ctx.scale(-1, 1);
            }

            if (animal.lastMoveDir.dx !== 0) { // Vista Lateral
                // Pernas
                ctx.fillStyle = legColor;
                ctx.fillRect(-4, 8, 4, 6); // Perna de trás
                ctx.fillRect(2, 8, 4, 6);  // Perna da frente

                // Corpo
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.arc(0, 2, 10 + woolSize, 0, Math.PI * 2);
                ctx.arc(5, 4, 7 + woolSize, 0, Math.PI * 2);
                ctx.fill();

                // Cabeça
                ctx.fillStyle = faceColor;
                ctx.beginPath();
                ctx.ellipse(10, -2 + headBob, 4, 5, 0, 0, Math.PI * 2);
                ctx.fillRect(12, -5 + headBob, 3, 3); // Orelha
                ctx.fill();

                // Chifre na vista lateral
                if (animal.gender === 'male') {
                    ctx.fillStyle = hornColor;
                    ctx.beginPath();
                    ctx.arc(8, -4 + headBob, 3, Math.PI * 1.5, Math.PI * 0.5, false);
                    ctx.fill();
                }

            } else { // Vista Frontal ou Traseira
                // Pernas
                ctx.fillStyle = legColor;
                ctx.fillRect(-6, 8, 4, 6); // Perna esquerda
                ctx.fillRect(2, 8, 4, 6);  // Perna direita

                // Corpo
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.arc(0, 2, 10 + woolSize, 0, Math.PI * 2); // Central
                ctx.arc(-6, 4, 6 + woolSize, 0, Math.PI * 2); // Esquerda
                ctx.arc(6, 4, 6 + woolSize, 0, Math.PI * 2); // Direita
                ctx.arc(0, -4, 8 + woolSize, 0, Math.PI * 2); // Topo
                ctx.fill();

                if (animal.lastMoveDir.dy >= 0) { // Olhando para baixo/frente
                    // Cabeça
                    ctx.fillStyle = faceColor;
                    ctx.beginPath();
                    ctx.ellipse(0, -6 + headBob, 5, 6, 0, 0, Math.PI * 2);
                    ctx.fillRect(-8, -8 + headBob, 3, 3); // Orelha esquerda
                    ctx.fillRect(5, -8 + headBob, 3, 3);  // Orelha direita
                    ctx.fill();

                    // Chifres para o carneiro (macho)
                    if (animal.gender === 'male') {
                        ctx.fillStyle = hornColor;
                        ctx.fillRect(-10, -12 + headBob, 4, 4);
                        ctx.fillRect(6, -12 + headBob, 4, 4);
                    }
                    ctx.fill();
                } else { // Olhando para cima/trás
                    // Apenas a parte de cima da cabeça é visível
                    ctx.fillStyle = faceColor;
                    ctx.beginPath();
                    ctx.arc(0, -10, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Chifres na vista traseira
                    if (animal.gender === 'male') {
                        ctx.fillStyle = hornColor;
                        ctx.beginPath();
                        ctx.arc(-5, -9, 3, Math.PI, Math.PI * 2);
                        ctx.arc(5, -9, 3, Math.PI, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            ctx.restore();

            // --- Desenha Indicadores de Status ---
            const indicatorY = y - 10;

            // Indicador de Fome
            if (animal.hunger >= 60 && animal.state !== 'eating') { // Aparece mais cedo
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(x + 8, indicatorY - 12, 16, 12, 4);
                ctx.stroke();
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.fillText('...', x + 16, indicatorY - 2);
            }

            // Barra de Progresso da Lã
            if (isAdult && animal.woolLevel < 100) {
                const barWidth = 28;
                ctx.fillStyle = '#333';
                ctx.fillRect(x + 2, indicatorY, barWidth, 6);
                ctx.fillStyle = '#4FC3F7'; // Azul claro
                ctx.fillRect(x + 2, indicatorY, barWidth * (animal.woolLevel / 100), 6);
            }
        }
        function drawSkeleton(ctx, x_px, y_px) {
            const boneColor = '#F5F5F5';
            ctx.fillStyle = boneColor;
            // Crânio
            ctx.fillRect(x_px + 12, y_px + 18, 8, 6);
            // Costelas
            ctx.fillRect(x_px + 8, y_px + 24, 16, 2);
            ctx.fillRect(x_px + 8, y_px + 27, 16, 2);
        }
        function drawClayTile(ctx, x_px, y_px, size) { // Sprite simplificado sem bordas
            const baseColor = '#A1887F'; // Um marrom mais acinzentado
            const highlightColor = 'rgba(255, 255, 255, 0.1)';
            
            ctx.fillStyle = baseColor;
            ctx.fillRect(x_px, y_px, size, size);

            // Detalhes de umidade
            ctx.fillStyle = highlightColor;
            ctx.beginPath(); ctx.ellipse(x_px + size * 0.7, y_px + size * 0.6, size * 0.2, size * 0.1, Math.PI / 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(x_px + size * 0.3, y_px + size * 0.3, size * 0.15, size * 0.1, -Math.PI / 4, 0, Math.PI * 2); ctx.fill();
        }
        function drawMountainWall(ctx, x_px, y_px, size) {
            const tileX = x_px / size;
            const tileY = y_px / size;
            const topColor = '#689F38'; // Verde do topo
            const mapObjects = worldData[player.currentFloor].mapObjects;
            const faceColor = '#6D4C41'; // Cor da face da rocha
            const shadowColor = '#4E342E'; // Sombra da rocha

            // Face da rocha (sempre visível)
            ctx.fillStyle = faceColor;
            ctx.fillRect(x_px, y_px, size, size);
            ctx.fillStyle = shadowColor;
            ctx.fillRect(x_px, y_px + size * 0.5, size, size * 0.5); // Metade inferior mais escura

            // Verifica se há uma parede de montanha acima
            const hasNeighborNorth = mapObjects.some(obj => obj.type === 8 && obj.x === tileX && obj.y === tileY - 1);

            // Desenha o topo de grama apenas se não houver vizinho ao norte
            if (!hasNeighborNorth) {
                ctx.fillStyle = topColor;
                ctx.fillRect(x_px, y_px, size, 8); // Tira de grama no topo
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(x_px, y_px + 8, size, 3); // Pequena sombra abaixo da grama
            }
        }
        function drawVoidTile(ctx, x_px, y_px, size) {
            ctx.fillStyle = '#000';
            ctx.fillRect(x_px, y_px, size, size);
        }
        function drawStairs(ctx, x_px, y_px, size, direction) {
            ctx.fillStyle = '#795548'; // Cor de madeira
            ctx.fillRect(x_px + 4, y_px + 4, size - 8, size - 8);
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 2;
            for (let i = 8; i < size - 4; i += 6) {
                ctx.strokeRect(x_px + 4, y_px + i, size - 8, 0);
            }
            ctx.fillStyle = '#FFD700'; // Seta amarela
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText(direction === 'up' ? '▲' : '▼', x_px + size / 2 - 5, y_px + size / 2 + 6);
        }
        function drawRoof(ctx, x_px, y_px, tileX, tileY, floor) {
            const floorData = worldData[floor];
            if (!floorData) return;
            const roofObjects = floorData.mapObjects.filter(obj => obj.type === 11);

            const hasN = roofObjects.some(o => o.x === tileX && o.y === tileY - 1);
            const hasS = roofObjects.some(o => o.x === tileX && o.y === tileY + 1);

            const mainColor = '#a84332';
            const highlightColor = '#d46a5a';
            const shadowColor = '#822d22';

            ctx.fillStyle = mainColor;
            ctx.fillRect(x_px, y_px, TILE_SIZE, TILE_SIZE);

            // Desenha as telhas como linhas horizontais
            for (let i = 0; i < TILE_SIZE; i += 8) {
                ctx.fillStyle = shadowColor;
                ctx.fillRect(x_px, y_px + i, TILE_SIZE, 2);
                ctx.fillStyle = highlightColor;
                ctx.fillRect(x_px, y_px + i + 2, TILE_SIZE, 1);
            }

            // Lógica para cumeeira e bordas
            if (!hasN) { // Borda superior (cumeeira)
                ctx.fillStyle = shadowColor;
                ctx.fillRect(x_px, y_px, TILE_SIZE, 10);
                ctx.fillStyle = mainColor;
                ctx.fillRect(x_px, y_px, TILE_SIZE, 8);
            }
            if (!hasS) { // Borda inferior
                ctx.fillStyle = shadowColor;
                ctx.fillRect(x_px, y_px + TILE_SIZE - 4, TILE_SIZE, 4);
            }
        }
        function preRenderMap() { for(let y=0; y<MAP_HEIGHT_TILES; y++){ for(let x=0; x<MAP_WIDTH_TILES; x++){ updatePreRenderedTile(x, y, worldData[player.currentFloor].map[y][x]); } } console.log(`Mapa do andar ${player.currentFloor} pré-renderizado!`); }
        function updatePreRenderedTile(tileX, tileY, tileId, floorIndex = player.currentFloor) {
            const dX=tileX*TILE_SIZE; const dY=tileY*TILE_SIZE;
            // A água (3) não é pré-renderizada, pois será animada
            if (!worldData[floorIndex]) return; // Segurança
            const preRenderedMapCtx = worldData[floorIndex].preRenderedMapCtx;
            if (tileId === 3) {
                preRenderedMapCtx.clearRect(dX, dY, TILE_SIZE, TILE_SIZE);
                return;
            }
            switch(tileId){
                case 0: drawGrassTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 1: drawEarthTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 2: drawPlowedTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                // case 3: drawWaterTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break; // Removido daqui
                case 4: drawSeedTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 5: drawSproutTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 6: drawPlantTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 7: drawHarvestableTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 8: drawFloorTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 9: drawClayTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 10: drawVoidTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 12: drawRedFlowerTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 13: drawYellowFlowerTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                case 14: drawSmallBushTile(preRenderedMapCtx, dX, dY, TILE_SIZE); break;
                default: drawGrassTile(preRenderedMapCtx, dX, dY, TILE_SIZE);
            }
        }
        function drawPlayer(timestamp) { const px=player.x; const py=player.y; const w=player.width; const h=player.height; let fB=0; if(player.isMoving){fB=Math.sin(player.walkBob)*2;}else if(player.isUsingTool){const aP=(timestamp-player.toolAnimStart)/TOOL_ANIM_DURATION; fB=Math.abs(Math.sin(aP*Math.PI))*6;} const bH=py+fB; ctx.fillStyle=player.colorLegs; ctx.fillRect(px, bH+h*0.6, w*0.45, h*0.4); ctx.fillRect(px+w*0.55, bH+h*0.6, w*0.45, h*0.4); ctx.fillStyle=player.colorBody; ctx.fillRect(px, bH+h*0.3, w, h*0.4); const hX=px+w*0.1; const hY=bH; const hW=w*0.8; const hH=h*0.4; ctx.fillStyle=player.colorHead; ctx.fillRect(hX, hY, hW, hH); ctx.fillStyle='#000'; const eS=2; let e1x, e1y, e2x, e2y; if(player.lastMoveDir.dy===1){e1x=hX+hW*0.25; e1y=hY+hH*0.6; e2x=hX+hW*0.75-eS; e2y=hY+hH*0.6;}else if(player.lastMoveDir.dy===-1){e1x=hX+hW*0.25; e1y=hY+hH*0.2; e2x=hX+hW*0.75-eS; e2y=hY+hH*0.2;}else if(player.lastMoveDir.dx===-1){e1x=hX+hW*0.2; e1y=hY+hH*0.4; e2x=hX+hW*0.5-eS; e2y=hY+hH*0.4;}else if(player.lastMoveDir.dx===1){e1x=hX+hW*0.5; e1y=hY+hH*0.4; e2x=hX+hW*0.8-eS; e2y=hY+hH*0.4;} if(e1x){ctx.fillRect(e1x, e1y, eS, eS); ctx.fillRect(e2x, e2y, eS, eS);} }
        function drawWaterAnimation(anim, timestamp) { const el=timestamp-anim.startTime; const pr=el/anim.duration; if(pr>1)return; const x=anim.x*TILE_SIZE+TILE_SIZE/2; const y=anim.y*TILE_SIZE+TILE_SIZE/2; for(let i=0; i<5; i++){ const an=i*(Math.PI*2/5)+pr*2; const ra=5+pr*15; const dX=x+Math.cos(an)*ra; const dY=y+Math.sin(an)*ra; ctx.fillStyle=`rgba(100,181,246, ${1-pr})`; ctx.beginPath(); ctx.arc(dX, dY, 2, 0, 2*Math.PI); ctx.fill(); } }
        function drawTileSelector() {
            if (mouseHoverTile.x === null || mouseHoverTile.y === null || isBackpackOpen) {
                return;
            }

            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);

            const dist = Math.sqrt(Math.pow(playerTileX - mouseHoverTile.x, 2) + Math.pow(playerTileY - mouseHoverTile.y, 2));

            // Só mostra o seletor em tiles próximos e interagíveis
            if (dist < 1.5) {
                const x_px = mouseHoverTile.x * TILE_SIZE;
                const y_px = mouseHoverTile.y * TILE_SIZE;

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x_px + 1, y_px + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            }
        }
        function drawPathIndicator(timestamp) {
            if (player.path.length > 0) {
                const finalTarget = player.path[player.path.length - 1];
                const x_px = finalTarget.x * TILE_SIZE;
                const y_px = finalTarget.y * TILE_SIZE;
                const size = 10 + Math.sin(timestamp * 0.005) * 4; // Animação pulsante
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.9)';
                ctx.lineWidth = 3;
                ctx.strokeRect(x_px + (TILE_SIZE - size) / 2, y_px + (TILE_SIZE - size) / 2, size, size);
            }
        }
        function drawConstructionGrid() {
            if (!isConstructionModeActive) return;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;

            const startX = Math.floor(camera.x / TILE_SIZE) * TILE_SIZE;
            const endX = Math.ceil((camera.x + canvas.width) / TILE_SIZE) * TILE_SIZE;
            const startY = Math.floor(camera.y / TILE_SIZE) * TILE_SIZE;
            const endY = Math.ceil((camera.y + canvas.height) / TILE_SIZE) * TILE_SIZE;

            for (let x = startX; x < endX; x += TILE_SIZE) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke(); }
            for (let y = startY; y < endY; y += TILE_SIZE) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke(); }
        }
        function drawConstructionPreview() {
            if (!isConstructionModeActive || mouseHoverTile.x === null || !player.toolSubAction || player.toolSubAction === 'pickup_mode') return;

            const x_px = mouseHoverTile.x * TILE_SIZE;
            const y_px = mouseHoverTile.y * TILE_SIZE;
            const mapObjects = worldData[player.currentFloor].mapObjects;

            switch (player.toolSubAction) {
                case 'build_wall':
                    drawWall(ctx, x_px, y_px);
                    break;
                case 'build_floor':
                    drawFloorTile(ctx, x_px, y_px, TILE_SIZE);
                    break;
                case 'build_fence':
                    drawFence(ctx, x_px, y_px, mouseHoverTile.x, mouseHoverTile.y, constructionTargetFloor);
                    break;
                case 'build_door':
                    const hasHorizontalWall = mapObjects.some(obj => obj.type === 5 && obj.y === mouseHoverTile.y && (obj.x === mouseHoverTile.x - 1 || obj.x === mouseHoverTile.x + 1));
                    drawDoor(ctx, x_px, y_px, hasHorizontalWall ? 'vertical' : 'horizontal', false);
                    break;
                case 'build_gate':
                    const hasHorizontalFence = mapObjects.some(obj => obj.type === 4 && obj.y === mouseHoverTile.y && (obj.x === mouseHoverTile.x - 1 || obj.x === mouseHoverTile.x + 1));
                    drawGate(ctx, x_px, y_px, hasHorizontalFence ? 'vertical' : 'horizontal', false);
                    break;
                case 'build_stairs':
                    drawStairs(ctx, x_px, y_px, TILE_SIZE, 'up');
                    break;
                case 'build_roof':
                    drawRoof(ctx, x_px, y_px, mouseHoverTile.x, mouseHoverTile.y, constructionTargetFloor);
                    break;
            }
        }
        function drawPlantingPreview() {
            if (isConstructionModeActive || mouseHoverTile.x === null) return;

            const bpIdx = hotbarMapping[activeHotbarSlot];
            if (bpIdx < 0 || !backpackInventory[bpIdx]) return;

            const item = ITEMS[backpackInventory[bpIdx].id];
            if (!item || !item.id.startsWith('seed_')) return;

            const tId = worldData[player.currentFloor].map[mouseHoverTile.y][mouseHoverTile.x];
            if (tId !== 2) return; // Só mostra em solo arado

            const x_px = mouseHoverTile.x * TILE_SIZE;
            const y_px = mouseHoverTile.y * TILE_SIZE;

            ctx.globalAlpha = 0.5;
            drawHarvestableTile(ctx, x_px, y_px, TILE_SIZE); // Mostra a planta madura
            ctx.globalAlpha = 1.0;
        }
        function drawAnimations(timestamp) { activeAnimations=activeAnimations.filter(an=>{const el=timestamp-an.startTime; if(el>an.duration)return false; if(an.type==='water'){drawWaterAnimation(an, timestamp);} return true;}); }
        function drawPlantTimers(timestamp) {
            const floorData = worldData[player.currentFloor];
            ctx.font = 'bold 12px Consolas';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 2;
            for (const key in floorData.plantGrowthData) {
                const [x, y] = key.split(',').map(Number);
                const data = floorData.plantGrowthData[key];
                const tId = floorData.map[y][x];
                if (tId >= 4 && tId <= 6) {
                    const tP = timestamp - data.plantedAt;
                    const eA = tP;
                    let taT = 0;
                    if (tId === 4) taT = GROWTH_TIME_SPROUT;
                    else if (tId === 5) taT = GROWTH_TIME_PLANT;
                    else if (tId === 6) taT = GROWTH_TIME_HARVEST;
                    if (data.boosted) { taT = taT * 0.5; }
                    const tL = Math.max(0, taT - eA);
                    const sL = Math.ceil(tL / 1000);
                    const dX = x * TILE_SIZE + (TILE_SIZE / 2);
                    const dY = y * TILE_SIZE - 5;
                    ctx.fillStyle = 'white';
                    ctx.fillText(`${sL}s`, dX, dY);
                }
            }
            ctx.shadowBlur = 0;
        }
        function updateGameTime() {
            const n=new Date(); const rH=n.getHours(); const rM=n.getMinutes(); const rS=n.getSeconds();
            const tS=(rH*3600 + rM*60 + rS) % (24 * 3600); // Segundos totais no dia real
            const p=tS/(24*3600); // Percentual do dia real
            let tM=Math.floor(GAME_MINUTES_PER_DAY*p); const oM=gameTimeOffset*60; tM=(tM+oM)%GAME_MINUTES_PER_DAY; gameHour=Math.floor(tM/60); gameMinute=tM%60;
            if (timeRangeSlider) { timeRangeSlider.value = gameHour; } // Sincroniza o slider com a hora do jogo
        }
        function updateNightOverlay() { if(!nightOverlay)return; const mO=0.7; let tO=0; if(gameHour>=20||gameHour<4)tO=mO; else if(gameHour===4)tO=mO*0.66; else if(gameHour===5)tO=mO*0.33; else if(gameHour>=6&&gameHour<18)tO=0; else if(gameHour===18)tO=mO*0.33; else if(gameHour===19)tO=mO*0.66; nightOverlay.style.opacity=tO; }
        function drawTimeIcon() { timeIconCtx.clearRect(0,0,timeIconCanvas.width,timeIconCanvas.height); const cX=timeIconCanvas.width/2; const cY=timeIconCanvas.height/2; const r=8; if(gameHour>=6&&gameHour<18){timeIconCtx.fillStyle='#FFD700'; timeIconCtx.beginPath(); timeIconCtx.arc(cX,cY,r,0,Math.PI*2); timeIconCtx.fill();}else{timeIconCtx.fillStyle='#A0A0A0'; timeIconCtx.beginPath(); timeIconCtx.arc(cX,cY,r,0,Math.PI*2); timeIconCtx.fill(); timeIconCtx.fillStyle='rgba(0,0,0,0)'; timeIconCtx.globalCompositeOperation='destination-out'; timeIconCtx.beginPath(); timeIconCtx.arc(cX+r*0.4,cY-r*0.4,r,0,Math.PI*2); timeIconCtx.fill(); timeIconCtx.globalCompositeOperation='source-over';} }
        function drawGameClock() { if(!gameClockSpan)return; const hS=String(gameHour).padStart(2,'0'); const mS=String(gameMinute).padStart(2,'0'); gameClockSpan.textContent=`${hS}:${mS}`; drawTimeIcon(); }
        function drawLighting(timestamp) { lightCtx.clearRect(0,0,lightCanvas.width,lightCanvas.height); if(gameHour>=18||gameHour<6){ lightCtx.save(); const cNO=nightOverlay?parseFloat(nightOverlay.style.opacity):0; lightCtx.fillStyle=`rgba(0,0,30,${cNO*0.9})`; lightCtx.fillRect(0,0,lightCanvas.width,lightCanvas.height); lightCtx.globalCompositeOperation='destination-out'; for(const obj of worldData[player.currentFloor].mapObjects){ const xOS=obj.x*TILE_SIZE-camera.x; const yOS=obj.y*TILE_SIZE-camera.y; let lR=0; let lX=xOS+TILE_SIZE/2; let lY=yOS+TILE_SIZE/2; if(obj.type===2){lR=3.5*TILE_SIZE;}else if(obj.type===3){lR=2.5*TILE_SIZE; lY=yOS+TILE_SIZE*0.75;} if(lR>0){if(lX+lR>0&&lX-lR<lightCanvas.width&&lY+lR>0&&lY-lR<lightCanvas.height){ const pu=Math.sin(timestamp*0.005)*0.05+0.95; const gr=lightCtx.createRadialGradient(lX,lY,0,lX,lY,lR*pu); gr.addColorStop(0,'rgba(255,255,255,1)'); gr.addColorStop(0.3,'rgba(255,255,255,0.9)'); gr.addColorStop(0.7,'rgba(255,255,255,0.5)'); gr.addColorStop(1,'rgba(255,255,255,0)'); lightCtx.fillStyle=gr; lightCtx.beginPath(); lightCtx.arc(lX,lY,lR*pu,0,Math.PI*2); lightCtx.fill();}}} lightCtx.globalCompositeOperation='source-over'; lightCtx.restore();} }
        
        function updatePlayerMovement(timestamp) {
            // Se não está se movendo, verifica se há um caminho a seguir
            if (!player.isMoving && player.path.length > 0) {
                const nextTile = player.path.shift(); // Pega o próximo tile do caminho
                const nextTargetX = nextTile.x * TILE_SIZE;
                const nextTargetY = nextTile.y * TILE_SIZE;

                // Define a direção do movimento para a animação do personagem
                const dx = nextTargetX - player.x;
                const dy = nextTargetY - player.y;
                if (Math.abs(dx) > Math.abs(dy)) { player.lastMoveDir = { dx: Math.sign(dx), dy: 0 }; }
                else { player.lastMoveDir = { dx: 0, dy: Math.sign(dy) }; }

                player.targetX = nextTargetX;
                player.targetY = nextTargetY;
                player.isMoving = true;
            }

            // Lógica de movimento suave para o próximo tile
            if (player.isMoving) {
                let dx = player.targetX - player.x;
                let dy = player.targetY - player.y;
                if (Math.abs(dx) < player.speed) player.x = player.targetX; else player.x += Math.sign(dx) * player.speed;
                if (Math.abs(dy) < player.speed) player.y = player.targetY; else player.y += Math.sign(dy) * player.speed;
                player.walkBob += player.walkBobSpeed;
                if (player.x === player.targetX && player.y === player.targetY) {
                    player.isMoving = false;
                    player.walkBob = 0;
                    if (player.path.length === 0) { // Chegou ao destino final
                        saveGame();

                        // --- Lógica de Transição Automática de Andar ---
                        // Verifica a escada DEPOIS que o movimento termina.
                        const playerTileX = Math.floor(player.x / TILE_SIZE);
                        const playerTileY = Math.floor(player.y / TILE_SIZE);
                        const stairIndex = worldData[player.currentFloor].mapObjects.findIndex(obj => obj.x === playerTileX && obj.y === playerTileY && (obj.type === 9 || obj.type === 10));
                        if (stairIndex !== -1) {
                            const stair = worldData[player.currentFloor].mapObjects[stairIndex];
                            changeFloor(stair);
                            return; // Interrompe para evitar bugs pós-transição
                        }
                    }
                }
            }
        }
        function updateToolAnimation(timestamp) { if(player.isUsingTool){if(timestamp-player.toolAnimStart>TOOL_ANIM_DURATION){player.isUsingTool=false; useTool(timestamp);}} }
        function updateAnimals(timestamp) {
            const floorData = worldData[player.currentFloor];
            if (!floorData || !floorData.animals) return;

            // --- Lógica de Reprodução (executada uma vez por frame) ---
            const ANIMAL_CAP = calculateAnimalCapacity(player.currentFloor);
            const ADULT_AGE = 100;
            if (Math.random() < 0.0001 && floorData.animals.length < ANIMAL_CAP) {
                const males = floorData.animals.filter(a => a.gender === 'male' && a.age >= ADULT_AGE);
                const females = floorData.animals.filter(a => a.gender === 'female' && a.age >= ADULT_AGE);

                if (males.length > 0 && females.length > 0) {
                    const mother = females[Math.floor(Math.random() * females.length)];
                    const newGender = Math.random() < 0.5 ? 'male' : 'female';
                    const newAnimal = {
                        type: 'sheep', gender: newGender,
                        age: 0, // Nasce como filhote
                        x: mother.x, y: mother.y,
                        state: 'idle', woolLevel: 0, hunger: 0, path: [], isMoving: false, speed: 1, walkBob: 0, walkBobSpeed: 0.1, lastMoveDir: { dx: 0, dy: 1 }, stateTimer: 0, timeAtMaxHunger: 0,
                        floor: mother.floor
                    };
                    floorData.animals.push(newAnimal);
                    console.log("Um novo cordeiro nasceu!");

                    // Feedback visual de coração
                    activeAnimations.push({ type: 'heart_feedback', x: mother.x + 16, y: mother.y, startTime: timestamp, duration: 2000 });
                }
            }


            // --- Lógica Individual de cada Animal ---
            floorData.animals = floorData.animals.filter(animal => {
                // Crescimento (idade e lã)
                if (animal.age < ADULT_AGE) {
                    animal.age += 0.01; // Taxa de crescimento
                } else {
                    // A lã só cresce em adultos e se não estiverem com fome
                    if (animal.hunger < 60 && animal.woolLevel < 100) {
                        animal.woolLevel += 0.02;
                    }
                }

                // Morte por fome
                if (animal.hunger >= 100) {
                    animal.timeAtMaxHunger = (animal.timeAtMaxHunger || 0) + 1;
                    const DEATH_THRESHOLD = 10800; // 3 minutos a 60fps
                    if (animal.timeAtMaxHunger > DEATH_THRESHOLD) {
                        const tileX = Math.floor(animal.x / TILE_SIZE);
                        const tileY = Math.floor(animal.y / TILE_SIZE);
                        floorData.mapObjects.push({ type: 15, x: tileX, y: tileY }); // type 15 = Esqueleto
                        console.log("Uma ovelha morreu de fome.");
                        return false; // Remove o animal da lista
                    }
                } else {
                    animal.timeAtMaxHunger = 0;
                }
                
                // Aumento da fome
                if (animal.hunger < 100) animal.hunger += 0.01;

                // Lógica de estado
                if (animal.state === 'eating') {
                    animal.stateTimer--;
                    if (animal.stateTimer <= 0) {
                        animal.state = 'idle';
                        animal.hunger = 0;
                        const tileX = Math.floor(animal.x / TILE_SIZE);
                        const tileY = Math.floor(animal.y / TILE_SIZE);
                        if (floorData.map[tileY][tileX] === 0) { // Se ainda for grama
                            floorData.map[tileY][tileX] = 1; // Transforma em terra
                            updatePreRenderedTile(tileX, tileY, 1);
                        }
                    }
                }

                // Lógica de movimento
                let currentSpeed = animal.speed;
                if (animal.hunger >= 80) {
                    currentSpeed = animal.speed * 0.5; // Fica mais lento
                }


                if (!animal.isMoving && animal.state === 'idle') {
                    // Tenta comer se estiver com fome
                    const currentTileX = Math.floor(animal.x / TILE_SIZE);
                    const currentTileY = Math.floor(animal.y / TILE_SIZE);
                    if (animal.hunger >= 80 && floorData.map[currentTileY][currentTileX] === 0) {
                        animal.state = 'eating';
                        animal.stateTimer = 180; // 3 segundos a 60fps
                    } else if (Math.random() < 0.005) { // Chance de começar a passear
                        const range = 4; // Raio de passeio
                        const targetTileX = currentTileX + Math.floor(Math.random() * (range * 2 + 1)) - range;
                        const targetTileY = currentTileY + Math.floor(Math.random() * (range * 2 + 1)) - range;

                        // O animal agora pode passear livremente, o pathfinding cuidará dos obstáculos
                        animal.path = findPath(currentTileX, currentTileY, targetTileX, targetTileY, (px, py) => isAnimalWalkable(px, py, animal));
                        if (animal.path.length > 0) {
                            animal.isMoving = true;
                            const firstStep = animal.path.shift();
                            animal.targetX = firstStep.x * TILE_SIZE;
                            animal.targetY = firstStep.y * TILE_SIZE;
                        }
                    }
                } else { // Se estiver se movendo
                    if (animal.path.length > 0 && (Math.abs(animal.x - animal.targetX) < currentSpeed && Math.abs(animal.y - animal.targetY) < currentSpeed)) {
                        const nextTile = animal.path.shift();
                        animal.targetX = nextTile.x * TILE_SIZE;
                        animal.targetY = nextTile.y * TILE_SIZE;
                    }

                    let dx = animal.targetX - animal.x;
                    let dy = animal.targetY - animal.y;

                    // Atualiza a direção do animal
                    if (Math.abs(dx) > Math.abs(dy)) {
                        animal.lastMoveDir = { dx: Math.sign(dx), dy: 0 };
                    } else if (dy !== 0) {
                        animal.lastMoveDir = { dx: 0, dy: Math.sign(dy) };
                    }

                    if (Math.abs(dx) < currentSpeed) animal.x = animal.targetX; else animal.x += Math.sign(dx) * currentSpeed;
                    if (Math.abs(dy) < currentSpeed) animal.y = animal.targetY; else animal.y += Math.sign(dy) * currentSpeed;
                    animal.walkBob += animal.walkBobSpeed;

                    if (animal.x === animal.targetX && animal.y === animal.targetY && animal.path.length === 0) {
                        animal.isMoving = false;
                        animal.walkBob = 0;
                    }
                }
                return true; // Mantém o animal na lista
            });
        }
        function updateCamera() { const tX=player.x-(640/2)+(player.width/2); const tY=player.y-(480/2)+(player.height/2); camera.x=Math.max(0,Math.min(tX,MAP_WIDTH_PX-canvas.width)); camera.y=Math.max(0,Math.min(tY,MAP_HEIGHT_PX-canvas.height)); }
        function update(timestamp) { updatePlayerMovement(timestamp); updateToolAnimation(timestamp); updateAnimals(timestamp); updateCamera(); }
        function draw(timestamp) {
            const fireAnimFrame = Math.floor(timestamp / 150) % 8; // 8 quadros, muda a cada 150ms
            const waterAnimFrame = Math.floor(timestamp / 250) % 8; // 8 quadros, muda a cada 250ms

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-camera.x, -camera.y);

            // --- Lógica de Desenho de Andares (Refatorada para Múltiplos Níveis) ---

            // 1. Desenha TODOS os andares ABAIXO do atual
            for (let i = player.currentFloor - 1; i >= 0; i--) {
                const lowerFloor = worldData[i];
                
                // 1a. Desenha o CHÃO e a ÁGUA do andar de baixo
                ctx.drawImage(lowerFloor.preRenderedMapCanvas, 0, 0);
                for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                    for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                        if (lowerFloor.map[y][x] === 3) {
                            ctx.drawImage(waterSpritesheetCanvas, waterAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }

                // 1b. Desenha os OBJETOS do andar de baixo
                for (const obj of lowerFloor.mapObjects) {
                    const x_px = obj.x * TILE_SIZE;
                    const y_px = obj.y * TILE_SIZE;
                    if (obj.type === 1) { drawTreeTrunk(ctx, x_px, y_px); drawTreeCanopy(ctx, x_px, y_px); }
                    else if (obj.type === 0) { drawRock(ctx, x_px, y_px); }
                    else if (obj.type === 9) { drawStairs(ctx, x_px, y_px, TILE_SIZE, 'up'); }
                    else if (obj.type === 4) { drawFence(ctx, x_px, y_px, obj.orientation); }
                    else if (obj.type === 2) { drawCampfire(ctx, x_px, y_px, timestamp); }
                    else if (obj.type === 3) { drawTorch(ctx, x_px, y_px, timestamp); }
                }

                // 1c. Aplica o escurecimento, que aumenta com a distância
                const darkness = 0.5 + (player.currentFloor - 1 - i) * 0.15;
                ctx.globalAlpha = Math.min(0.85, darkness); // Limita o escurecimento máximo
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, MAP_WIDTH_PX, MAP_HEIGHT_PX);
                ctx.globalAlpha = 1.0;
            }


            // 2. Desenha o chão do andar atual
            const currentFloorCanvas = worldData[player.currentFloor].preRenderedMapCanvas; // Re-obtém para clareza
            const currentMap = worldData[player.currentFloor].map;
            // Se estiver em um andar superior, desenha apenas os tiles não vazios
            if (player.currentFloor > 0) {
                 for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                    for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                        if (currentMap[y][x] !== 10) { // 10 é o tile de Vazio
                            ctx.drawImage(currentFloorCanvas, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            } else {
                // Se estiver no térreo, desenha o mapa inteiro de uma vez
                ctx.drawImage(currentFloorCanvas, 0, 0);
            }
            // Desenha a água animada do andar atual
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    if (currentMap[y][x] === 3) {
                        ctx.drawImage(waterSpritesheetCanvas, waterAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // 3. Coleta e desenha os OBJETOS do andar atual
            const mapObjects = worldData[player.currentFloor].mapObjects;
            let drawables = [];
            drawables.push({ type: 'player', x_px: player.x, y_px: player.y, y_sort: player.y + player.height - 4, draw: (ts) => drawPlayer(ts) });
            drawables.push({ type: 'shadow', x_px: player.x, y_px: player.y, y_sort: player.y + player.height - 5, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(player.x+player.width/2, player.y+player.height+2, player.width/2.5, 4, 0, 0, 2*Math.PI); ctx.fill();} });
            for (const obj of mapObjects) {
                const x_px = obj.x * TILE_SIZE; const y_px = obj.y * TILE_SIZE; const y_base = y_px + TILE_SIZE;
                if (obj.type === 0) { // Rocha
                     drawables.push({ type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base - 1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x_px+16, y_base, 12, 6, 0, 0, 2*Math.PI); ctx.fill();} });
                    drawables.push({ type: 'rock', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawRock(ctx, x_px, y_px) });
                } else if (obj.type === 1) { // Árvore
                     drawables.push({ type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base -1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x_px+TILE_SIZE/2, y_base, TILE_SIZE*0.75, TILE_SIZE*0.4, 0, 0, 2*Math.PI); ctx.fill();} });
                    drawables.push({ type: 'tree_trunk', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawTreeTrunk(ctx, x_px, y_px) });
                    drawables.push({ type: 'tree_canopy', x_px: x_px, y_px: y_px, y_sort: y_base + TILE_SIZE * 2, draw: () => drawTreeCanopy(ctx, x_px, y_px) });
                } else if (obj.type === 2) { // Fogueira
                    drawables.push({ type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base - 1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(x_px+16, y_base, 10, 5, 0, 0, 2*Math.PI); ctx.fill();} });
                    drawables.push({ type: 'campfire', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => ctx.drawImage(campfireSpritesheetCanvas, fireAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x_px, y_px, TILE_SIZE, TILE_SIZE) });
                } else if (obj.type === 3) { // Tocha
                    drawables.push({ type: 'torch', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => ctx.drawImage(torchSpritesheetCanvas, fireAnimFrame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE, x_px, y_px, TILE_SIZE, TILE_SIZE) });
                } else if (obj.type === 4) { // Cerca - usa a orientação do objeto
                    drawables.push({ type: 'fence', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawFence(ctx, x_px, y_px, obj.x, obj.y, player.currentFloor) });
                } else if (obj.type === 5) { // Muro
                    drawables.push({ type: 'wall', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawWall(ctx, x_px, y_px) });
                } else if (obj.type === 6) { // Porta
                    drawables.push({ type: 'door', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawDoor(ctx, x_px, y_px, obj.orientation, obj.isOpen) });
                } else if (obj.type === 7) { // Porteira
                    drawables.push({ type: 'gate', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawGate(ctx, x_px, y_px, obj.orientation, obj.isOpen) });
                } else if (obj.type === 8) { // Parede de Montanha
                    drawables.push({ type: 'mountain_wall', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawMountainWall(ctx, x_px, y_px, TILE_SIZE) });
                } else if (obj.type === 9) { // Escada para Cima
                    drawables.push({ type: 'stairs_up', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawStairs(ctx, x_px, y_px, TILE_SIZE, 'up') });
                } else if (obj.type === 10) { // Escada para Baixo
                    drawables.push({ type: 'stairs_down', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawStairs(ctx, x_px, y_px, TILE_SIZE, 'down') });
                } else if (obj.type === 15) { // Esqueleto
                    drawables.push({ type: 'skeleton', x_px: x_px, y_px: y_px, y_sort: y_base, draw: () => drawSkeleton(ctx, x_px, y_px) });
                } else if (obj.type === 11) { // Telhado
                    drawables.push({ type: 'roof', x_px: x_px, y_px: y_px, y_sort: y_base + TILE_SIZE, draw: () => drawRoof(ctx, x_px, y_px, obj.x, obj.y, player.currentFloor) });
                }
            }

            // 3a. Adiciona os animais do andar atual à lista de desenháveis
            const animals = worldData[player.currentFloor].animals;
            for (const animal of animals) {
                drawables.push({ type: 'shadow', x_px: animal.x, y_px: animal.y, y_sort: animal.y + 28 - 1, draw: ()=>{ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.beginPath(); ctx.ellipse(animal.x+16, animal.y+28, 12, 6, 0, 0, 2*Math.PI); ctx.fill();} });
                drawables.push({ type: 'animal', x_px: animal.x, y_px: animal.y, y_sort: animal.y + 28, draw: () => drawSheep(ctx, animal) });
            }

            drawables.sort((a, b) => a.y_sort - b.y_sort);
            for (const item of drawables) { item.draw(timestamp); }

            // 4. Desenha os EFEITOS do andar atual
            drawAnimations(timestamp); drawPlantTimers(timestamp);
            drawTileSelector();
            drawPlantingPreview();
            drawPathIndicator(timestamp);
            drawConstructionPreview();
            drawConstructionGrid();

            // 4a. Desenha animações de feedback de recursos
            activeAnimations.forEach(anim => {
                if (anim.type === 'resource_feedback') {
                    const elapsed = timestamp - anim.startTime;
                    const progress = elapsed / anim.duration;
                    if (progress < 1) {
                        const yOffset = -20 - (progress * 30); // Move para cima
                        const alpha = 1 - progress; // Desaparece
                        ctx.font = 'bold 16px Consolas';
                        ctx.fillStyle = `rgba(${anim.color}, ${alpha})`;
                        ctx.fillText(anim.text, anim.x, anim.y + yOffset);
                    }
                }
            });

            // Animação de coração da reprodução
            activeAnimations.forEach(anim => {
                if (anim.type === 'heart_feedback') {
                    const elapsed = timestamp - anim.startTime;
                    const progress = elapsed / anim.duration;
                    if (progress < 1) {
                        const yOffset = -10 - (progress * 20);
                        const alpha = 1 - (progress * progress);
                        ctx.font = '24px sans-serif';
                        ctx.globalAlpha = alpha;
                        ctx.fillText('❤️', anim.x, anim.y + yOffset);
                        ctx.globalAlpha = 1.0;
                    }
                }
            });

            // 5. Verifica se o jogador está "debaixo" de algo no andar de cima
            let isPlayerUnderSomething = false;
            if (worldData[player.currentFloor + 1]) { // Só verifica se houver um andar de cima
                const playerTileX = Math.floor((player.x + player.width / 2) / TILE_SIZE);
                const playerTileY = Math.floor((player.y + player.height / 2) / TILE_SIZE);
                const upperFloor = worldData[player.currentFloor + 1];

                // Verifica uma área de 3x3 tiles no andar de cima, em torno da posição do jogador
                for (let y = playerTileY - 1; y <= playerTileY + 1; y++) {
                    for (let x = playerTileX - 1; x <= playerTileX + 1; x++) {
                        if (x >= 0 && x < MAP_WIDTH_TILES && y >= 0 && y < MAP_HEIGHT_TILES) {
                            // Se houver qualquer tile que não seja vazio...
                            if (upperFloor.map[y][x] !== 10) {
                                isPlayerUnderSomething = true;
                                break;
                            }
                            // Ou se houver qualquer objeto...
                            if (upperFloor.mapObjects.some(obj => obj.x === x && obj.y === y)) {
                                isPlayerUnderSomething = true;
                                break;
                            }
                        }
                    }
                    if (isPlayerUnderSomething) break;
                }
            }

            // 6. Desenha TODOS os andares ACIMA (se não estiver debaixo de nada)
            if (!isPlayerUnderSomething) {
                for (let i = player.currentFloor + 1; i < worldData.length; i++) {
                    const upperFloor = worldData[i];
                    const upperFloorCanvas = upperFloor.preRenderedMapCanvas;
                    const opacity = 0.5 - (i - (player.currentFloor + 1)) * 0.15; // Fica mais transparente com a distância
                    if (opacity <= 0) continue;

                    ctx.filter = 'saturate(0)'; // Efeito acinzentado
                    ctx.globalAlpha = opacity;

                    // Desenha o chão e os objetos do andar superior
                    for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                        for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                            if (upperFloor.map[y][x] !== 10) ctx.drawImage(upperFloorCanvas, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                    for (const obj of upperFloor.mapObjects) {
                        // Desenha todos os objetos, EXCETO o telhado, com transparência
                        if (obj.type !== 11) {
                            const x_px = obj.x * TILE_SIZE; const y_px = obj.y * TILE_SIZE;
                            if (obj.type === 1) { drawTreeTrunk(ctx, x_px, y_px); drawTreeCanopy(ctx, x_px, y_px); } else if (obj.type === 0) { drawRock(ctx, x_px, y_px); } else if (obj.type === 5) { drawWall(ctx, x_px, y_px); } else if (obj.type === 10) { drawStairs(ctx, x_px, y_px, TILE_SIZE, 'down'); }
                        }
                    }
                }
                // Restaura o estado normal do canvas após o loop
                ctx.globalAlpha = 1.0;
                ctx.filter = 'none';

                // 7. Desenha os telhados por cima de tudo, com opacidade total
                for (let i = player.currentFloor + 1; i < worldData.length; i++) {
                    const upperFloor = worldData[i];
                    for (const obj of upperFloor.mapObjects) {
                        if (obj.type === 11) drawRoof(ctx, obj.x * TILE_SIZE, obj.y * TILE_SIZE, obj.x, obj.y, i);
                    }
                }
            }

            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) { if (!lastTime) lastTime = timestamp; lastTime = timestamp; update(timestamp); draw(timestamp); drawLighting(timestamp); requestAnimationFrame(gameLoop); }
        
        // --- Lógica do Jogo ---
        // CORRIGIDO: Keydown listener
        document.addEventListener('keydown', (e) => {
            if (isContextMenuOpen) return;
            // Teclas que funcionam mesmo com a mochila aberta
            if (e.key === 'b' || e.key === 'B') {
                console.log("Tecla B pressionada"); // DEBUG
                e.preventDefault();
                toggleBackpack();
                return;
            }
             if (e.key === 'Escape' && isBackpackOpen) {
                 e.preventDefault();
                 toggleBackpack(false); // Força fechar
                 return;
             }

             // Bloqueia outras ações se a mochila estiver aberta
             if (isBackpackOpen) {
                 // e.preventDefault(); // Não previne aqui, pode atrapalhar inputs futuros
                 return; // Simplesmente ignora a ação no jogo
             }

             // Bloqueia se estiver se movendo ou usando ferramenta
             if (player.isMoving || player.isUsingTool) return;

            // Tecla Ctrl para abrir menu de contexto
            if (e.key === 'Control' && !isConstructionModeActive) { // Menu de contexto só no modo normal por enquanto
                e.preventDefault();
                openContextMenu(activeHotbarSlot);
                return;
            }

            // Teclas 1-0 para Hotbar
            let slotIndex = -1;
            if (e.key >= '1' && e.key <= '9') { slotIndex = parseInt(e.key, 10) - 1; }
            else if (e.key === '0') { slotIndex = 9; }
            if (slotIndex !== -1) {
                e.preventDefault();
                updateActiveHotbarSlot(slotIndex);
                return;
            }

            // Tecla Espaço para Usar
            if (e.key === ' ') { e.preventDefault(); triggerUseTool(); return; }
            player.path = []; // Qualquer tecla de movimento cancela o caminho do mouse

            // Movimento com Setas
            let newDir = null;
            switch (e.key) { case 'ArrowUp': newDir = {dx:0, dy:-1}; break; case 'ArrowDown': newDir = {dx:0, dy:1}; break; case 'ArrowLeft': newDir = {dx:-1, dy:0}; break; case 'ArrowRight': newDir = {dx:1, dy:0}; break; }
            if (!newDir) return; // Ignora outras teclas
            triggerMovementOrTurn(newDir); // Chama a função helper
        });

        // Função helper para adicionar itens ao inventário
        function addItemToInventory(itemId, quantity) {
            const itemDefinition = ITEMS[itemId];
            if (!itemDefinition) { console.warn(`Tentativa de adicionar item desconhecido: ${itemId}`); return; }
            let itemIndex = backpackInventory.findIndex(i => i && i.id === itemId && itemDefinition.stackable);
            if (itemIndex !== -1) {
                backpackInventory[itemIndex].count += quantity;
            } else {
                let emptyBackpackSlot = backpackInventory.findIndex(slot => slot === null);
                if (emptyBackpackSlot !== -1) {
                    backpackInventory[emptyBackpackSlot] = { id: itemId, count: quantity };
                    // Tenta mapear para um slot vazio da hotbar, se houver
                    let emptyHotbarSlot = hotbarMapping.findIndex(mapping => mapping === -1);
                    if (emptyHotbarSlot !== -1) {
                        hotbarMapping[emptyHotbarSlot] = emptyBackpackSlot;
                    }
                } else {
                    console.warn(`Mochila cheia, não foi possível adicionar ${quantity} de ${itemDefinition.name}.`);
                }
            }
            // Adiciona feedback visual de ganho
            activeAnimations.push({
                type: 'resource_feedback',
                text: `+${quantity}`,
                color: '144, 238, 144', // Verde claro
                x: player.x + player.width / 2,
                y: player.y,
                startTime: lastTime,
                duration: 1500
            });
        }

        function useTool(timestamp) {
            const tX = (player.toolTarget && player.toolTarget.x !== null) ? player.toolTarget.x : Math.floor(player.x/TILE_SIZE) + player.lastMoveDir.dx;
            const tY = (player.toolTarget && player.toolTarget.y !== null) ? player.toolTarget.y : Math.floor(player.y/TILE_SIZE) + player.lastMoveDir.dy;
            if (tX < 0 || tX >= MAP_WIDTH_TILES || tY < 0 || tY >= MAP_HEIGHT_TILES) return;
            const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
            const currentSlot = isConstructionModeActive ? activeConstructionHotbarSlot : activeHotbarSlot;
            const bpIdx = currentMapping[currentSlot];

            const targetFloorIndex = isConstructionModeActive ? constructionTargetFloor : player.currentFloor;
            const floorData = worldData[targetFloorIndex];
            if (!floorData) return;

            if (bpIdx < 0 || !backpackInventory[bpIdx]) return;
            const inventoryItem = backpackInventory[bpIdx];
            if (!inventoryItem) return;
            const item = ITEMS[inventoryItem.id];

            // --- Lógica de Interação com Animais ---
            const animal = floorData.animals.find(a => tX >= Math.floor(a.x / TILE_SIZE) && tX < Math.ceil((a.x + TILE_SIZE) / TILE_SIZE) && tY >= Math.floor(a.y / TILE_SIZE) && tY < Math.ceil((a.y + TILE_SIZE) / TILE_SIZE));
            if (animal) {
                if (item.id === 'shears' && animal.type === 'sheep' && animal.woolLevel >= 100 && animal.age >= 100) {
                    animal.woolLevel = 0;
                    addItemToInventory('wool', 1);
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // Ação concluída
                }
            }

            // Verifica se há um objeto no tile alvo
            const objectIndex = floorData.mapObjects.findIndex(obj => obj.x === tX && obj.y === tY);
            if (objectIndex !== -1) {
                const targetObject = floorData.mapObjects[objectIndex];
                if (item.name === "Picareta" && targetObject.type === 0) { // Rocha
                    floorData.mapObjects.splice(objectIndex, 1); // Remove a rocha
                    const stoneGained = Math.floor(Math.random() * 11) + 5; // Ganho de 5 a 15 pedras
                    addItemToInventory('stone', stoneGained);
                    console.log(`Rocha quebrada! Ganhou ${stoneGained} pedras.`);
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // Ação concluída
                }
                if (item.name === "Machado" && targetObject.type === 1) { // Árvore
                    floorData.mapObjects.splice(objectIndex, 1); // Remove a árvore
                    const woodGained = Math.floor(Math.random() * 11) + 5; // Ganho de 5 a 15 madeiras
                    addItemToInventory('wood', woodGained);
                    console.log(`Árvore cortada! Ganhou ${woodGained} madeiras.`);
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // Ação concluída
                }
                if (item.name === "Pá" && targetObject.type === 4) { // Cerca
                    floorData.mapObjects.splice(objectIndex, 1); // Remove a cerca
                    addItemToInventory('wood', 1); // Devolve 1 madeira
                    console.log("Cerca removida!");
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // Ação concluída
                }
                if (item.name === "Pá" && targetObject.type === 15) { // Esqueleto
                    floorData.mapObjects.splice(objectIndex, 1); // Remove o esqueleto
                    console.log("Esqueleto removido.");
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    return; // Ação concluída
                }

                // Lógica Universal de "Pegar"
                if (item.name === "Construção" && player.toolSubAction === 'pickup_mode') {
                    let pickedUpItem = null;
                    if (targetObject.type === 4) pickedUpItem = 'fence';
                    else if (targetObject.type === 5) pickedUpItem = 'wall';
                    else if (targetObject.type === 6) pickedUpItem = 'door';
                    else if (targetObject.type === 7) pickedUpItem = 'gate';
                    else if (targetObject.type === 11) pickedUpItem = 'roof';

                    if (pickedUpItem) {
                        floorData.mapObjects.splice(objectIndex, 1);
                        addItemToInventory(pickedUpItem, 1);
                        console.log(`${pickedUpItem} coletado(a)!`);
                        saveGame();
                        updateHotbarUI();
                        updateBackpackUI();
                        return;
                    }
                    else if (targetObject.type === 7) pickedUpItem = 'gate';
                    else if (targetObject.type === 9) { floorData.mapObjects.splice(objectIndex, 1); const otherStairIndex = worldData[targetObject.targetFloor].mapObjects.findIndex(o => o.x === targetObject.targetX && o.y === targetObject.targetY && o.type === 10); if(otherStairIndex !== -1) worldData[targetObject.targetFloor].mapObjects.splice(otherStairIndex, 1); addItemToInventory('wood', 20); pickedUpItem = 'stairs'; }
                    else if (targetObject.type === 10) { floorData.mapObjects.splice(objectIndex, 1); const otherStairIndex = worldData[targetObject.targetFloor].mapObjects.findIndex(o => o.x === targetObject.targetX && o.y === targetObject.targetY && o.type === 9); if(otherStairIndex !== -1) worldData[targetObject.targetFloor].mapObjects.splice(otherStairIndex, 1); addItemToInventory('wood', 20); pickedUpItem = 'stairs'; }

                    if (pickedUpItem) {
                        floorData.mapObjects.splice(objectIndex, 1);
                        addItemToInventory(pickedUpItem, 1);
                        console.log(`${pickedUpItem} coletado(a)!`);
                        saveGame();
                        updateHotbarUI();
                        updateBackpackUI();
                        return;
                    }
                }

                return; // Impede o uso da ferramenta no chão se houver um objeto
            }

            // Se não houver objeto, continua com a lógica para o chão
            const tK = `${tX},${tY}`;
            const tId = floorData.map[tY][tX];

            // Lógica de Colheita
            if (tId === 7) {
                floorData.map[tY][tX] = 2; // Volta para solo arado
                delete floorData.plantGrowthData[tK]; // Remove os dados de crescimento da planta
                addItemToInventory('tomato', 1);
                const seedsGained = Math.floor(Math.random() * 4); // 0, 1, 2 ou 3 sementes
                if (seedsGained > 0) addItemToInventory('seed_tomato', seedsGained);
                updatePreRenderedTile(tX, tY, 2);
                saveGame(); updateHotbarUI(); updateBackpackUI(); return;
            }

            // Lógica Universal de "Pegar" para pisos
            if (item.name === "Construção" && player.toolSubAction === 'pickup_mode' && tId === 8) {
                floorData.map[tY][tX] = 0; // Volta para grama
                addItemToInventory('wood', 1); // Devolve 1 madeira
                updatePreRenderedTile(tX, tY, 0);
                console.log("Piso removido!");
                saveGame();
                updateHotbarUI();
                updateBackpackUI();
                return;
            }

            switch (item.name) {
                case "Enxada": if (tId === 0 || tId === 1) { floorData.map[tY][tX] = 2; updatePreRenderedTile(tX, tY, 2); saveGame(); } break;
                case "Semente": if (tId === 2 && inventoryItem.count > 0) { floorData.map[tY][tX] = 4; floorData.plantGrowthData[tK] = { plantedAt: timestamp, boosted: false }; inventoryItem.count--; updatePreRenderedTile(tX, tY, 4); saveGame(); updateHotbarUI(); updateBackpackUI(); } break;
                case "Pá":
                    if (tId === 9) { // Coleta argila
                        const clayGained = Math.floor(Math.random() * 5) + 1; // 1 a 5
                        addItemToInventory('clay', clayGained);
                        floorData.map[tY][tX] = 1; // Volta para terra
                        updatePreRenderedTile(tX, tY, 1);
                        console.log(`Coletou ${clayGained} de argila.`);
                        saveGame();
                        updateHotbarUI();
                        updateBackpackUI();
                    } else if (tId === 8) { // Remove piso de madeira
                        floorData.map[tY][tX] = 0; // Volta para grama
                        addItemToInventory('wood', 1); // Devolve 1 madeira
                        updatePreRenderedTile(tX, tY, 0);
                        saveGame();
                    } else if (tId === 1 || tId === 2 || (tId >= 4 && tId <= 7)) {
                        floorData.map[tY][tX] = 0; if (floorData.plantGrowthData[tK]) delete floorData.plantGrowthData[tK]; updatePreRenderedTile(tX, tY, 0); saveGame();
                    } else if (tId === 0) {
                        let aW = false; const ne = [[0, 1], [0, -1], [1, 0], [-1, 0]]; for (const [nx, ny] of ne) { const cX = tX + nx; const cY = tY + ny; if (cX >= 0 && cX < MAP_WIDTH_TILES && cY >= 0 && cY < MAP_HEIGHT_TILES) { if (floorData.map[cY][cX] === 3) { aW = true; break; } } } if (aW) { floorData.map[tY][tX] = 3; updatePreRenderedTile(tX, tY, 3); saveGame(); }
                    } else if (tId === 3) {
                        floorData.map[tY][tX] = 0; updatePreRenderedTile(tX, tY, 0); saveGame();
                    }
                    break;
                case "Regador": {
                    if (tId === 3) { inventoryItem.count = 10; updateHotbarUI(); updateBackpackUI(); saveGame(); }
                    else if (inventoryItem.count > 0) {
                        let actionTaken = false;
                        if (tId === 1 || tId === 2) { // Terra ou Arado -> Argila
                            floorData.map[tY][tX] = 9; updatePreRenderedTile(tX, tY, 9); actionTaken = true;
                        } else if (tId >= 4 && tId <= 6) { // Regar planta
                            const pD = floorData.plantGrowthData[tK]; if (pD && !pD.boosted) { pD.boosted = true; actionTaken = true; }
                        }
                        if (actionTaken) {
                            inventoryItem.count--; activeAnimations.push({ type: 'water', x: tX, y: tY, startTime: timestamp, duration: 500 }); updateHotbarUI(); updateBackpackUI(); saveGame();
                        }
                    }
                    break; }
                case "Construção":
                    if (objectIndex !== -1) break; // Não constrói sobre objetos existentes

                    if (player.toolSubAction === 'build_wall') {
                        if (tId === 0 || tId === 1 || tId === 8) { // Permite construir muro em piso de madeira
                            const wallItemIdx = backpackInventory.findIndex(i => i && i.id === 'wall' && i.count > 0);
                            const stoneIdx = backpackInventory.findIndex(i => i && i.id === 'stone' && i.count >= 5);
                            if (wallItemIdx !== -1) {
                                backpackInventory[wallItemIdx].count--;
                                triggerResourceFeedback(-1, 'Muro');
                            } else if (stoneIdx !== -1) {
                                backpackInventory[stoneIdx].count -= 5;
                                triggerResourceFeedback(-5, 'Pedra');
                            }
                            else { console.log("Sem muros ou pedras (mín. 5) para construir."); break; } floorData.mapObjects.push({ type: 5, x: tX, y: tY });
                            console.log("Muro construído!");
                        }
                    } else if (player.toolSubAction === 'build_floor') {
                        if (tId === 0 || tId === 1 || tId === 10) { // Permite construir piso no vazio
                            const woodIdx = backpackInventory.findIndex(i => i && i.id === 'wood' && i.count > 0);
                            if (woodIdx !== -1) {
                                backpackInventory[woodIdx].count--;
                                triggerResourceFeedback(-1, 'Madeira');
                                floorData.map[tY][tX] = 8; // type 8 = Piso
                                updatePreRenderedTile(tX, tY, 8);
                                console.log("Piso construído!");
                            } else { console.log("Sem madeira para construir o piso."); break; }
                        }
                    } else if (player.toolSubAction === 'build_door') {
                        if (tId === 8) { // Apenas em piso
                            const hasHorizontalWall = floorData.mapObjects.some(obj => obj.type === 5 && obj.y === tY && (obj.x === tX - 1 || obj.x === tX + 1));
                            const hasVerticalWall = floorData.mapObjects.some(obj => obj.type === 5 && obj.x === tX && (obj.y === tY - 1 || obj.y === tY + 1));
                            if (!hasHorizontalWall && !hasVerticalWall) { console.log("A porta deve ser construída ao lado de um muro."); break; }

                            const doorItemIdx = backpackInventory.findIndex(i => i && i.id === 'door' && i.count > 0);
                            const woodIdx = backpackInventory.findIndex(i => i && i.id === 'wood' && i.count >= 4);
                            if (doorItemIdx !== -1) {
                                backpackInventory[doorItemIdx].count--;
                                triggerResourceFeedback(-1, 'Porta');
                            } else if (woodIdx !== -1) {
                                backpackInventory[woodIdx].count -= 4;
                                triggerResourceFeedback(-4, 'Madeira');
                            }
                            else { console.log("Sem Portas ou Madeira (mín. 4) para construir."); break; }
                            const orientation = hasHorizontalWall ? 'vertical' : 'horizontal';
                            floorData.mapObjects.push({ type: 6, x: tX, y: tY, orientation: orientation, isOpen: false }); // type 6 = Porta
                            console.log("Porta construída!");
                        } else { console.log("A porta deve ser construída sobre um piso de madeira."); break; }
                    } else if (player.toolSubAction === 'build_gate') {
                        if (tId === 0 || tId === 1) {
                            const hasHorizontalFence = floorData.mapObjects.some(obj => obj.type === 4 && obj.y === tY && (obj.x === tX - 1 || obj.x === tX + 1));
                            const hasVerticalFence = floorData.mapObjects.some(obj => obj.type === 4 && obj.x === tX && (obj.y === tY - 1 || obj.y === tY + 1));
                            if (!hasHorizontalFence && !hasVerticalFence) { console.log("A porteira deve ser construída ao lado de uma cerca."); break; }

                            const gateItemIdx = backpackInventory.findIndex(i => i && i.id === 'gate' && i.count > 0);
                            const woodIdx = backpackInventory.findIndex(i => i && i.id === 'wood' && i.count >= 4);
                            if (gateItemIdx !== -1) {
                                backpackInventory[gateItemIdx].count--;
                                triggerResourceFeedback(-1, 'Porteira');
                            } else if (woodIdx !== -1) {
                                backpackInventory[woodIdx].count -= 4;
                                triggerResourceFeedback(-4, 'Madeira');
                            }
                            else { console.log("Sem Porteiras ou Madeira (mín. 4) para construir."); break; }
                            const orientation = hasHorizontalFence ? 'vertical' : 'horizontal';
                            floorData.mapObjects.push({ type: 7, x: tX, y: tY, orientation: orientation, isOpen: false }); // type 7 = Porteira
                            console.log("Porteira construída!");
                        }
                    } else if (player.toolSubAction === 'build_fence' || player.toolSubAction === null) {
                        if (tId === 0 || tId === 1) {
                            if (player.toolSubAction === 'pickup_mode') break; // Modo pegar não constrói
                            const fenceItemIdx = backpackInventory.findIndex(i => i && i.id === 'fence' && i.count > 0);
                            const woodIdx = backpackInventory.findIndex(i => i && i.id === 'wood' && i.count > 0);
                            if (fenceItemIdx !== -1) {
                                backpackInventory[fenceItemIdx].count--;
                                triggerResourceFeedback(-1, 'Cerca');
                            } else if (woodIdx !== -1) {
                                backpackInventory[woodIdx].count--;
                                triggerResourceFeedback(-1, 'Madeira');
                            } else { console.log("Sem cercas ou madeira para construir."); break; }
                            floorData.mapObjects.push({ type: 4, x: tX, y: tY }); // A orientação é determinada dinamicamente
                            }
                            console.log("Cerca construída!");
                    } else if (player.toolSubAction === 'build_stairs') { // Lógica atualizada para usar constructionTargetFloor
                        const upperFloorIndex = targetFloorIndex + 1;
                        if (tId === 8) { // A escada é construída no andar alvo, sobre um piso
                            // Se o andar de cima não existir, cria um novo
                            if (!worldData[upperFloorIndex]) {
                                worldData[upperFloorIndex] = createNewFloorData(createEmptyFloorLayout(), []);
                                preRenderAllFloors(); // Atualiza o cache de renderização
                                console.log(`Andar ${upperFloorIndex} criado dinamicamente!`);
                            }

                            const targetTileIsFree = worldData[upperFloorIndex].mapObjects.every(obj => obj.x !== tX || obj.y !== tY);
                            if (targetTileIsFree) {
                                const woodIdx = backpackInventory.findIndex(i => i && i.id === 'wood' && i.count >= 5);
                                if (woodIdx !== -1) {
                                    backpackInventory[woodIdx].count -= 5;
                                    triggerResourceFeedback(-5, 'Madeira');
                                    floorData.mapObjects.push({ type: 9, x: tX, y: tY, targetFloor: upperFloorIndex, targetX: tX, targetY: tY }); // Escada para cima
                                    worldData[upperFloorIndex].mapObjects.push({ type: 10, x: tX, y: tY, targetFloor: targetFloorIndex, targetX: tX, targetY: tY }); // Escada para baixo
                                    console.log("Escada construída!");
                                } else { console.log("Madeira insuficiente (mín. 5)."); }
                            } else { console.log("O local no andar de cima está bloqueado."); }
                        } else {
                            if (tId !== 8) console.log("Escadas devem ser construídas sobre um piso de madeira.");
                        }
                    } else if (player.toolSubAction === 'build_roof') {
                        const lowerFloorIndex = targetFloorIndex - 1;
                        if (lowerFloorIndex < 0) {
                            console.log("Não se pode construir telhado no térreo.");
                            break;
                        }
                        const lowerFloor = worldData[lowerFloorIndex];
                        const hasSupport = lowerFloor && (lowerFloor.map[tY][tX] !== 10 || lowerFloor.mapObjects.some(obj => obj.x === tX && obj.y === tY));

                        if (hasSupport) {
                            const clayIdx = backpackInventory.findIndex(i => i && i.id === 'clay' && i.count >= 1);
                            if (clayIdx !== -1) {
                                backpackInventory[clayIdx].count -= 1;
                                triggerResourceFeedback(-1, 'Argila');
                                floorData.mapObjects.push({ type: 11, x: tX, y: tY }); // type 11 = Telhado
                                console.log("Telhado construído!");
                            } else { console.log("Argila insuficiente (mín. 1)."); }
                        } else {
                            console.log("O telhado precisa de suporte no andar de baixo.");
                        }
                    }
                    // Salva e atualiza a UI se qualquer ação de construção foi bem-sucedida
                    saveGame();
                    updateHotbarUI();
                    updateBackpackUI();
                    break;
                case "Machado": console.log("Usou Machado no chão"); break; // Ação em objeto já tratada
                case "Picareta": console.log("Usou Picareta no chão"); break; // Ação em objeto já tratada
            }
        }

        function isWalkable(pixelX, pixelY) {
            const tX = Math.floor(pixelX / TILE_SIZE);
            const tY = Math.floor(pixelY / TILE_SIZE);
            const floorData = worldData[player.currentFloor]; // Corrigido
            if (tX < 0 || tX >= MAP_WIDTH_TILES || tY < 0 || tY >= MAP_HEIGHT_TILES) return false;

            const tileId = floorData.map[tY][tX];
            const objectOnTile = floorData.mapObjects.find(obj => obj.x === tX && obj.y === tY);

            if (tileId === 3) return false; // Água é sempre intransponível
            if (tileId === 10 && (!objectOnTile || (objectOnTile.type !== 9 && objectOnTile.type !== 10))) return false; // Vazio é intransponível, a menos que tenha uma escada

            if (objectOnTile) { if (objectOnTile.type === 0 || objectOnTile.type === 1 || objectOnTile.type === 2 || objectOnTile.type === 8 || objectOnTile.type === 11) return false; if ((objectOnTile.type === 4 || objectOnTile.type === 5 || objectOnTile.type === 6 || objectOnTile.type === 7) && !objectOnTile.isOpen) return false; }
            return true;
        }

        function isAnimalWalkable(pixelX, pixelY, movingAnimal) {
            const tX = Math.floor(pixelX / TILE_SIZE);
            const tY = Math.floor(pixelY / TILE_SIZE);
            const floorData = worldData[movingAnimal.floor]; // Usa o andar do animal

            // Usa a função base de caminhada para verificar terreno e objetos
            if (!isWalkable(pixelX, pixelY)) return false;

            // Verifica colisão com o jogador
            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);
            if (tX === playerTileX && tY === playerTileY) return false;

            // Verifica colisão com outros animais
            for (const otherAnimal of floorData.animals) {
                if (otherAnimal !== movingAnimal) {
                    const otherAnimalTileX = Math.floor(otherAnimal.x / TILE_SIZE);
                    const otherAnimalTileY = Math.floor(otherAnimal.y / TILE_SIZE);
                    if (tX === otherAnimalTileX && tY === otherAnimalTileY) return false;
                }
            }

            return true;
        }

        function calculateAnimalCapacity(floorIndex) {
            const floorData = worldData[floorIndex];
            if (!floorData) return 0;

            let grassTiles = 0;
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    if (floorData.map[y][x] === 0) grassTiles++;
                }
            }
            return Math.floor(grassTiles / 4); // 1 animal para cada 4 tiles de grama
        }

        function updatePlantGrowth(timestamp) { const floorData = worldData[player.currentFloor]; let mC=false; for(const key in floorData.plantGrowthData){ const[x,y]=key.split(',').map(Number); const data=floorData.plantGrowthData[key]; const tP=timestamp-data.plantedAt; const eA=tP; const cId=floorData.map[y][x]; const bM=data.boosted?0.5:1; const tS=GROWTH_TIME_SPROUT*bM; const tP_=GROWTH_TIME_PLANT*bM; const tH=GROWTH_TIME_HARVEST*bM; let nId=-1; if(eA>tH&&cId===6)nId=7; else if(eA>tP_&&cId===5)nId=6; else if(eA>tS&&cId===4)nId=5; if(nId!==-1){floorData.map[y][x]=nId; updatePreRenderedTile(x,y,nId); mC=true;} } if(mC){saveGame();} }
        function startGrowthTimer() { setInterval(() => { updatePlantGrowth(lastTime); }, 1000); }

        // --- Funções de UI ---
        // CORRIGIDO: updateHotbarUI e updateBackpackUI
        function updateHotbarUI() {
            const slots = hotbarElement.querySelectorAll('.slot');
            slots.forEach((slot, hotbarIndex) => {
                const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
                const currentActiveSlot = isConstructionModeActive ? activeConstructionHotbarSlot : activeHotbarSlot; // Usa o slot ativo correto
                const backpackIndex = currentMapping[hotbarIndex];
                const inventoryItem = (backpackIndex !== -1 && backpackIndex >= 0 && backpackIndex < backpackInventory.length) ? backpackInventory[backpackIndex] : null;
                const item = inventoryItem ? ITEMS[inventoryItem.id] : null;
                const nameSpan = slot.querySelector('.slot-name');
                const subActionSpan = slot.querySelector('.slot-sub-action');
                const countSpan = slot.querySelector('.slot-count');

                if (item && nameSpan && countSpan && subActionSpan) {
                    nameSpan.textContent = item.name;
                    const isCountable = item.stackable || item.category === 'ferramenta' && inventoryItem.count > 0; // Regador tem contagem
                    countSpan.textContent = (isCountable && inventoryItem.count > 0) ? `x${inventoryItem.count}` : "";
                    
                    // Mostra a sub-ação no slot ativo
                    if (hotbarIndex === currentActiveSlot && player.toolSubAction) {
                        if (player.toolSubAction === 'pickup_mode') subActionSpan.textContent = "(Pegar)";
                        else if (player.toolSubAction === 'build_door') subActionSpan.textContent = "(Construir)";
                        else if (player.toolSubAction === 'build_gate') subActionSpan.textContent = "(Construir)";
                        else if (player.toolSubAction === 'build_floor') subActionSpan.textContent = "(Piso)";
                        else if (player.toolSubAction === 'build_wall') subActionSpan.textContent = "(Construir)";
                        else if (player.toolSubAction === 'vertical_fence') subActionSpan.textContent = "(Vertical)";
                        else if (player.toolSubAction === 'horizontal_fence') subActionSpan.textContent = "(Horizontal)";
                        else subActionSpan.textContent = "";
                    } else {
                        subActionSpan.textContent = "";
                    }
                } else {
                    nameSpan.textContent = "";
                    subActionSpan.textContent = "";
                    countSpan.textContent = "";
                }

                slot.classList.toggle('active', hotbarIndex === currentActiveSlot);
                slot.classList.remove('dragging', 'drag-over');
            });
        }

        function updateBackpackUI() {
            backpackGrid.innerHTML = '';
            backpackInventory.forEach((item, index) => {
                // Oculta a ferramenta de construção da mochila principal
                if (item && item.id === 'construction_tool') return;

                const slot = document.createElement('div');
                slot.classList.add('slot');
                slot.dataset.backpackIndex = index;

                const nameSpan = document.createElement('span');
                nameSpan.classList.add('slot-name');

                const countSpan = document.createElement('span');
                countSpan.classList.add('slot-count');

                if (item && item.id) {
                    const itemDefinition = ITEMS[item.id];
                    nameSpan.textContent = itemDefinition.name;
                    const isCountable = itemDefinition.stackable || itemDefinition.category === 'ferramenta' && item.count > 0;
                    countSpan.textContent = (isCountable && item.count > 0) ? `x${item.count}` : "";
                } else {
                    nameSpan.textContent = "";
                    countSpan.textContent = "";
                }

                slot.appendChild(nameSpan);
                slot.appendChild(countSpan);

                if (index === selectedBackpackIndex) { slot.classList.add('selected-for-assignment'); }
                slot.addEventListener('click', handleBackpackSlotClick);
                // Adiciona listeners para o tooltip
                slot.addEventListener('mouseover', showTooltip);
                slot.addEventListener('mouseout', hideTooltip);
                backpackGrid.appendChild(slot);
            });
        }

        // --- Lógica do Tooltip ---
        function showTooltip(event) {
            const slot = event.currentTarget;
            let itemName = null;

            if (slot.parentElement.id === 'hotbar') {
                const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
                const hotbarIndex = parseInt(slot.dataset.hotbarIndex, 10);
                const backpackIndex = currentMapping[hotbarIndex];
                if (backpackIndex !== -1 && backpackInventory[backpackIndex] && ITEMS[backpackInventory[backpackIndex].id]) {
                    itemName = ITEMS[backpackInventory[backpackIndex].id].name;
                }
            } else if (slot.parentElement.id === 'constructionGrid') {
                const backpackIndex = parseInt(slot.dataset.backpackIndex, 10);
                if (backpackInventory[backpackIndex] && ITEMS[backpackInventory[backpackIndex].id]) {
                    itemName = ITEMS[backpackInventory[backpackIndex].id].name;
                }
            } else if (slot.parentElement.id === 'backpackGrid') {
                const backpackIndex = parseInt(slot.dataset.backpackIndex, 10);
                if (backpackInventory[backpackIndex] && ITEMS[backpackInventory[backpackIndex].id]) {
                    itemName = ITEMS[backpackInventory[backpackIndex].id].name;
                }
            }

            const itemDefinition = Object.values(ITEMS).find(i => i.name === itemName);
            if (itemDefinition && itemDefinition.description) {
                const slotRect = slot.getBoundingClientRect();
                const containerRect = gameContainer.getBoundingClientRect();

                itemTooltip.innerHTML = itemDefinition.description;
                itemTooltip.style.display = 'block';

                // Calcula a posição ideal (acima e centralizado)
                let top = slotRect.top - containerRect.top - itemTooltip.offsetHeight - 10; // 10px de margem
                let left = slotRect.left - containerRect.left + (slotRect.width / 2) - (itemTooltip.offsetWidth / 2);

                // Garante que não saia pelos lados
                if (left < 5) left = 5;
                if (left + itemTooltip.offsetWidth > containerRect.width - 5) {
                    left = containerRect.width - itemTooltip.offsetWidth - 5;
                }
                // Se sair por cima, mostra embaixo
                if (top < 5) {
                    top = slotRect.top - containerRect.top + slotRect.height + 10;
                }

                itemTooltip.style.top = `${top}px`;
                itemTooltip.style.left = `${left}px`;
            }
        }

        function hideTooltip() {
            itemTooltip.style.display = 'none';
        }

        // --- Lógica do Menu de Contexto ---
        function openContextMenu(hotbarIndex) {
            if (isBackpackOpen) return;
            const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
            const backpackIndex = currentMapping[hotbarIndex];
            if (backpackIndex === -1 || !backpackInventory[backpackIndex]) return;

            const inventoryItem = backpackInventory[backpackIndex];
            const item = ITEMS[inventoryItem.id];
            const slotElement = hotbarElement.querySelector(`[data-hotbar-index="${hotbarIndex}"]`);
            const slotRect = slotElement.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();

            contextMenu.innerHTML = ''; // Limpa o menu

            const actions = item.actions || [];
            
            // Adiciona ações específicas do item
            actions.forEach(actionInfo => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                menuItem.textContent = actionInfo.label;
                menuItem.onclick = () => handleContextMenuAction(actionInfo, hotbarIndex);
                contextMenu.appendChild(menuItem);
            });

            // Adiciona a ação "Guardar" para todos
            const storeItem = document.createElement('div');
            storeItem.className = 'context-menu-item';
            storeItem.textContent = 'Guardar';
            storeItem.onclick = () => handleContextMenuAction({ action: 'store' }, hotbarIndex);
            contextMenu.appendChild(storeItem);

            // Posiciona e exibe o menu
            contextMenu.style.display = 'block';
            isContextMenuOpen = true;

            let top = slotRect.top - containerRect.top - contextMenu.offsetHeight - 5;
            let left = slotRect.left - containerRect.left;

            // Ajusta se sair da tela
            if (top < 5) top = slotRect.bottom - containerRect.top + 5;
            if (left + contextMenu.offsetWidth > containerRect.width - 5) {
                left = containerRect.width - contextMenu.offsetWidth - 5;
            }

            contextMenu.style.top = `${top}px`;
            contextMenu.style.left = `${left}px`;
        }

        function closeContextMenu() {
            contextMenu.style.display = 'none';
            isContextMenuOpen = false;
        }

        function handleContextMenuAction(actionInfo, hotbarIndex) {
            console.log("Ação do menu de contexto:", actionInfo.label, "no slot", hotbarIndex);
            switch (actionInfo.action) {
                case 'set_sub_action':
                    player.toolSubAction = actionInfo.value;
                    console.log("Sub-ação definida:", player.toolSubAction);
                    break;
                case 'store':
                    const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
                    currentMapping[hotbarIndex] = -1;
                    updateHotbarUI();
                    saveGame();
                    break;
                case 'log':
                    console.log(actionInfo.value);
                    break;
            }
            closeContextMenu();
        }

        function updateActiveHotbarSlot(hotbarIndex) {
            if (hotbarIndex >= 0 && hotbarIndex < HOTBAR_SIZE) { 
                if (isConstructionModeActive) {
                    if (activeConstructionHotbarSlot !== hotbarIndex) player.toolSubAction = null;
                    activeConstructionHotbarSlot = hotbarIndex;
                } else {
                    if (activeHotbarSlot !== hotbarIndex) player.toolSubAction = null;
                    activeHotbarSlot = hotbarIndex;
                }
                saveGame(); updateHotbarUI();
            }
        }

        function updateConstructionUI() {
            constructionGrid.innerHTML = '';
            const constructionSlots = new Array(20).fill(null);
            let currentSlotIndex = 0;

            // Filtra apenas os itens de construção
            backpackInventory.forEach((item, index) => {
                if (item && item.id) {
                    const itemDef = ITEMS[item.id];
                    if (itemDef && (itemDef.category === 'construcao' || itemDef.category === 'material_construcao' || itemDef.id === 'construction_tool')) {
                        if (currentSlotIndex < 20) {
                            constructionSlots[currentSlotIndex] = { item: item, originalIndex: index };
                            currentSlotIndex++;
                        }
                    }
                }
            });

            constructionSlots.forEach(slotData => {
                const slot = document.createElement('div');
                slot.classList.add('slot');

                if (slotData) {
                    const { item: inventoryItem, originalIndex } = slotData;
                    const item = ITEMS[inventoryItem.id];
                    slot.dataset.backpackIndex = originalIndex; // Mantém o índice original da mochila

                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('slot-name');
                    nameSpan.textContent = item.name;

                    const countSpan = document.createElement('span');
                    countSpan.classList.add('slot-count');
                    if (item.category !== 'ferramenta' && inventoryItem.count > 0) {
                        countSpan.textContent = `x${inventoryItem.count}`;
                    }

                    slot.appendChild(nameSpan);
                    slot.appendChild(countSpan);

                    if (originalIndex === selectedConstructionIndex) {
                        slot.classList.add('selected-for-assignment');
                    }
                    slot.addEventListener('click', handleConstructionSlotClick);
                    slot.addEventListener('mouseover', showTooltip);
                    slot.addEventListener('mouseout', hideTooltip);
                }

                constructionGrid.appendChild(slot);
            });
        }

        function toggleConstructionInventory(forceState = null) {
            if (isContextMenuOpen) closeContextMenu();
            isConstructionInventoryOpen = (forceState !== null) ? forceState : !isConstructionInventoryOpen;
            if (isConstructionInventoryOpen) {
                selectedConstructionIndex = -1; updateConstructionUI(); constructionContainer.style.display = 'flex';
            } else {
                constructionContainer.style.display = 'none';
            }
        }

        // --- Lógica Mochila ---
        function toggleBackpack(forceState = null) {
            if (isContextMenuOpen) closeContextMenu();
            if (isConstructionModeActive) toggleConstructionMode(false); // Fecha o modo construção
            isBackpackOpen = (forceState !== null) ? forceState : !isBackpackOpen;
            if (isBackpackOpen) {
                selectedBackpackIndex = -1; updateBackpackUI(); backpackContainer.style.display = 'flex';
            } else {
                backpackContainer.style.display = 'none';
                const sel = backpackGrid.querySelector('.selected-for-assignment'); if(sel) sel.classList.remove('selected-for-assignment');
            }
        }

        function handleBackpackSlotClick(event) {
             if (!isBackpackOpen) return;
             const clickedIndex = parseInt(event.currentTarget.dataset.backpackIndex, 10);
             const prevSel = backpackGrid.querySelector('.selected-for-assignment'); if (prevSel) prevSel.classList.remove('selected-for-assignment');
             if (clickedIndex === selectedBackpackIndex) { selectedBackpackIndex = -1; }
             else { selectedBackpackIndex = clickedIndex; event.currentTarget.classList.add('selected-for-assignment'); console.log(`Selecionado item da mochila: ${selectedBackpackIndex}`); }
        }

        function handleConstructionSlotClick(event) {
            if (!isConstructionModeActive) return;
            // dataset.backpackIndex pode não existir em slots vazios
            if (event.currentTarget.dataset.backpackIndex) {
                const clickedIndex = parseInt(event.currentTarget.dataset.backpackIndex, 10);
                if (clickedIndex === selectedConstructionIndex) {
                    selectedConstructionIndex = -1; // Desseleciona se clicar no mesmo item
                } else {
                    selectedConstructionIndex = clickedIndex; // Seleciona o novo item
                }
                console.log(`Selecionado item de construção (índice da mochila): ${selectedConstructionIndex}`);
                updateConstructionUI(); // Redesenha a UI para mostrar a seleção
            }
        }

        function handleHotbarSlotClick(event) {
            const clickedHotbarIndex = parseInt(event.currentTarget.dataset.hotbarIndex, 10);
            if (isBackpackOpen) {
                if (selectedBackpackIndex !== -1) {
                    const currentMapping = hotbarMapping; // Mochila só interage com a hotbar normal
                    console.log(`Atribuindo mochila[${selectedBackpackIndex}] -> hotbar[${clickedHotbarIndex}]`);
                    const existingHotbarSlot = currentMapping.indexOf(selectedBackpackIndex);
                    if(existingHotbarSlot !== -1) { hotbarMapping[existingHotbarSlot] = -1; }
                    currentMapping[clickedHotbarIndex] = selectedBackpackIndex;
                    selectedBackpackIndex = -1;
                    updateBackpackUI(); updateHotbarUI(); saveGame();
                    closeContextMenu();
                } // CORREÇÃO: Lógica de atribuição para construção
            } else if (isConstructionModeActive) {
                if (selectedConstructionIndex !== -1) {
                    const existingHotbarSlot = constructionHotbarMapping.indexOf(selectedConstructionIndex);
                    if (existingHotbarSlot !== -1) { constructionHotbarMapping[existingHotbarSlot] = -1; }
                    constructionHotbarMapping[clickedHotbarIndex] = selectedConstructionIndex;
                    selectedConstructionIndex = -1;
                    updateConstructionUI(); updateHotbarUI(); saveGame();
                }
            } else {
                const currentActiveSlot = isConstructionModeActive ? activeConstructionHotbarSlot : activeHotbarSlot;
                if (clickedHotbarIndex === currentActiveSlot && !player.isMoving && !player.isUsingTool) {
                     const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
                     const bpIdx = currentMapping[currentActiveSlot];
                     if(bpIdx !== -1 && backpackInventory[bpIdx] && ITEMS[backpackInventory[bpIdx].id]){
                        // Se uma sub-ação foi escolhida, usa a ferramenta imediatamente
                        if (player.toolSubAction) {
                            triggerUseTool();
                        }
                        console.log("Clique para usar slot ativo:", activeHotbarSlot); // DEBUG
                        triggerUseTool(); // Chama a função helper
                     }
                } else {
                    updateActiveHotbarSlot(clickedHotbarIndex);
                }
            }
        }


        // --- Lógica Drag & Drop ---
        let draggedHotbarIndex = -1;
        function handleDragStart(event) { if(isBackpackOpen) { event.preventDefault(); return; } const targetSlot = event.target.closest('.slot'); if(!targetSlot || !targetSlot.dataset.hotbarIndex) { event.preventDefault(); return; } draggedHotbarIndex = parseInt(targetSlot.dataset.hotbarIndex, 10); event.dataTransfer.setData('text/plain', draggedHotbarIndex); event.dataTransfer.effectAllowed = 'move'; setTimeout(() => targetSlot.classList.add('dragging'), 0); console.log("Drag Start:", draggedHotbarIndex); }
        function handleDragOver(event) { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; const targetSlot = event.target.closest('.slot'); if(targetSlot && targetSlot.parentElement.id === 'hotbar'){ hotbarElement.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); targetSlot.classList.add('drag-over'); } }
        function handleDragLeave(event) { const targetSlot = event.target.closest('.slot'); if(targetSlot && targetSlot.parentElement.id === 'hotbar'){ targetSlot.classList.remove('drag-over'); } }
        function handleDrop(event) {
            event.preventDefault();
            const targetSlot = event.target.closest('.slot');
            if (!targetSlot || draggedHotbarIndex === -1 || targetSlot.parentElement.id !== 'hotbar') { cleanupDragDrop(); return; }
            const droppedOnHotbarIndex = parseInt(targetSlot.dataset.hotbarIndex, 10);
            console.log("Drop:", draggedHotbarIndex, "onto", droppedOnHotbarIndex);
            if (draggedHotbarIndex !== droppedOnHotbarIndex) {
                const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
                const sourceMapping = currentMapping[draggedHotbarIndex];
                const targetMapping = currentMapping[droppedOnHotbarIndex];
                currentMapping[draggedHotbarIndex] = targetMapping;
                currentMapping[droppedOnHotbarIndex] = sourceMapping;
                saveGame(); updateHotbarUI();
            }
            cleanupDragDrop();
        }
        function handleDragEnd(event) { cleanupDragDrop(); }
        function cleanupDragDrop(){ draggedHotbarIndex = -1; hotbarElement.querySelectorAll('.slot').forEach(slot => { slot.classList.remove('dragging', 'drag-over'); }); console.log("Drag End / Cleanup"); }


        // --- Persistência ---
        function ensureInventoryConsistency(backpack, mapping, defaultItems) {
            while(backpack.length < BACKPACK_SIZE) backpack.push(null); if(backpack.length > BACKPACK_SIZE) backpack.length = BACKPACK_SIZE;
            while(mapping.length < HOTBAR_SIZE) mapping.push(-1); if(mapping.length > HOTBAR_SIZE) mapping.length = HOTBAR_SIZE;
             defaultItems.forEach((defaultItemInfo, defaultIndex) => {
                 let foundIndex = backpack.findIndex(i => i && i.id === defaultItemInfo.id);
                 if(foundIndex === -1) {
                     let emptySlotIndex = backpack.findIndex(slot => slot === null);
                    if (emptySlotIndex !== -1) {
                        backpack[emptySlotIndex] = { id: defaultItemInfo.id, count: defaultItemInfo.count };
                         foundIndex = emptySlotIndex;
                         console.log(`Adicionado item padrão "${ITEMS[defaultItemInfo.id].name}" no slot vazio ${foundIndex}`);
                     } else { console.warn(`Mochila cheia, não foi possível adicionar item padrão "${ITEMS[defaultItemInfo.id].name}"`); }
                 }
                 if (defaultIndex < HOTBAR_SIZE && mapping[defaultIndex] === -1 && foundIndex !== -1) {
                      const isMappedElsewhere = mapping.includes(foundIndex);
                      if (!isMappedElsewhere) { mapping[defaultIndex] = foundIndex; console.log(`Mapeado item padrão "${ITEMS[defaultItemInfo.id].name}" (mochila ${foundIndex}) para hotbar ${defaultIndex}`); }
                 }
            });
            for (let i = 0; i < mapping.length; i++) { if (mapping[i] !== -1 && (mapping[i] >= BACKPACK_SIZE || !backpack[mapping[i]])) { console.log(`Limpando mapeamento inválido da hotbar ${i} (apontava para ${mapping[i]})`); mapping[i] = -1; } }
        }
        function saveGame() {
            const saveData = {
                player: {
                    x: player.x,
                    y: player.y,
                    currentFloor: player.currentFloor,
                    lastMoveDir: { dx: player.lastMoveDir.dx, dy: player.lastMoveDir.dy }
                },
                worldData: worldData.map(floor => ({ map: floor.map, mapObjects: floor.mapObjects, plantGrowthData: floor.plantGrowthData, animals: floor.animals.map(a => ({...a, path: []})) })), // Não salva o path
                backpackData: backpackInventory,
                hotbarMapData: hotbarMapping,
                activeSlotData: activeHotbarSlot,
                constructionHotbarMapData: constructionHotbarMapping,
                activeConstructionSlotData: activeConstructionHotbarSlot,
                gameTimeOffset: gameTimeOffset
            };
            localStorage.setItem('pixelFarmSaveData', JSON.stringify(saveData));
            console.log("Jogo salvo!");
        }
        // CORRIGIDO: loadGame
        function loadGame() {
            const defaultItems = [ { id: 'hoe', count: 1 }, { id: 'seed_tomato', count: 10 }, { id: 'shovel', count: 1 }, { id: 'watering_can', count: 0 }, { id: 'shears', count: 1 }, { id: 'construction_tool', count: 1 }, { id: 'axe', count: 1 }, { id: 'pickaxe', count: 1 } ];

            const savedData = localStorage.getItem('pixelFarmSaveData');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    // Carrega a estrutura do mundo
                    if (data.worldData && Array.isArray(data.worldData)) {
                        worldData = data.worldData.map(floorData => {
                            const newFloor = createNewFloorData(floorData.map || WORLD_LAYOUT, floorData.mapObjects || []);
                            newFloor.plantGrowthData = floorData.plantGrowthData || {};
                            newFloor.animals = floorData.animals || [];
                            return newFloor;
                        });
                    } else { // Migração de save antigo
                        const floor0 = createNewFloorData(data.map || WORLD_LAYOUT, data.mapObjects || initialMapObjects);
                        floor0.plantGrowthData = data.plantData || {};
                        worldData.push(floor0);
                    }

                    if (data.player) {
                        if (typeof data.player.x === 'number') player.x = data.player.x;
                        if (typeof data.player.y === 'number') player.y = data.player.y;
                        if (data.player.lastMoveDir && typeof data.player.lastMoveDir.dx === 'number' && typeof data.player.lastMoveDir.dy === 'number') {
                            player.lastMoveDir = { dx: data.player.lastMoveDir.dx, dy: data.player.lastMoveDir.dy };
                        }
                        if (typeof data.player.currentFloor === 'number') player.currentFloor = data.player.currentFloor;
                        // Garante que o player não comece se movendo ou com target diferente
                        player.targetX = player.x;
                        player.targetY = player.y;
                        player.isMoving = false;
                    }

                    if (data.activeSlotData !== undefined && data.activeSlotData >= 0 && data.activeSlotData < HOTBAR_SIZE) { activeHotbarSlot = data.activeSlotData; }

                    // Carrega inventário e hotbar do save, ou usa arrays vazios se não existirem
                    let loadedBackpack = (data.backpackData && Array.isArray(data.backpackData)) ? data.backpackData : new Array(BACKPACK_SIZE).fill(null);
                    // Migração de save antigo (baseado em nome) para novo (baseado em ID)
                    loadedBackpack.forEach((item, index) => {
                        if (item && item.name && !item.id) {
                            const foundItem = Object.values(ITEMS).find(def => def.name === item.name);
                            if (foundItem) loadedBackpack[index] = { id: foundItem.id, count: item.count };
                        }
                    });
                    backpackInventory = loadedBackpack;
                    hotbarMapping = (data.hotbarMapData && Array.isArray(data.hotbarMapData)) ? data.hotbarMapData : new Array(HOTBAR_SIZE).fill(-1);
                    constructionHotbarMapping = (data.constructionHotbarMapData && Array.isArray(data.constructionHotbarMapData)) ? data.constructionHotbarMapData : new Array(HOTBAR_SIZE).fill(-1);
                    if (data.activeConstructionSlotData !== undefined) activeConstructionHotbarSlot = data.activeConstructionSlotData;

                    if (typeof data.gameTimeOffset === 'number') { gameTimeOffset = data.gameTimeOffset; }

                    // Re-valida a consistência APÓS carregar, para limpar mapeamentos ruins do save
                    // e adicionar itens padrão caso o save seja de uma versão antiga.
                    ensureInventoryConsistency(backpackInventory, hotbarMapping, defaultItems);

                    console.log("Jogo carregado.");
                } catch (e) {
                    console.error("Erro ao carregar o save, usando dados padrão.", e);
                     // Reset em caso de erro de parse - cria um jogo novo
                     worldData = [createNewFloorData(WORLD_LAYOUT, initialMapObjects)];
                     backpackInventory = new Array(BACKPACK_SIZE).fill(null); hotbarMapping = new Array(HOTBAR_SIZE).fill(-1); ensureInventoryConsistency(backpackInventory, hotbarMapping, defaultItems); activeHotbarSlot = 0; gameTimeOffset = 0;
                }
            } else {
                console.log("Nenhum save encontrado, iniciando novo jogo.");
                const floor0 = createNewFloorData(WORLD_LAYOUT, validatedInitialObjects);
                // Adiciona a propriedade 'floor' a cada animal inicial
                floor0.animals = JSON.parse(JSON.stringify(initialAnimals)).map(a => ({ ...a, floor: 0 }));
                worldData.push(floor0);
                worldData.push(createNewFloorData(createFloor1Layout(), floor1Objects)); // Andar 1
                backpackInventory = new Array(BACKPACK_SIZE).fill(null);
                hotbarMapping = new Array(HOTBAR_SIZE).fill(-1);
                activeHotbarSlot = 0;
                ensureInventoryConsistency(backpackInventory, hotbarMapping, defaultItems);
            }
            preRenderAllFloors();
        }

        function preRenderAllFloors() {
            if (!worldData || worldData.length === 0) return;
            for (let i = 0; i < worldData.length; i++) {
                for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                    for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                        updatePreRenderedTile(x, y, worldData[i].map[y][x], i);
                    }
                }
                console.log(`Mapa do andar ${i} pré-renderizado!`);
            }
        }


        // --- Funções Helper para Controles (CORRIGIDO) ---
        function triggerUseTool(targetTile = null) {
             // Bloqueia se mochila aberta ou já em ação
             if (isBackpackOpen || player.isMoving || player.isUsingTool ) return;
             if (isContextMenuOpen) closeContextMenu();

             const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
             const currentSlot = isConstructionModeActive ? activeConstructionHotbarSlot : activeHotbarSlot;
             const bpIdx = currentMapping[currentSlot];

             const inventoryItem = backpackInventory[bpIdx];
             if (!inventoryItem || !ITEMS[inventoryItem.id]) return; // Slot vazio, inválido ou item desconhecido

             player.toolTarget = targetTile; // Armazena o alvo do clique (pode ser null)

             console.log("Trigger Use Tool - Slot:", activeHotbarSlot);
             player.isMoving = false; // Garante que parou de andar
             player.isUsingTool = true;
             player.toolAnimStart = lastTime; // Usa o timestamp do loop
        }

        function triggerMovementOrTurn(newDir) {
             // Bloqueia se mochila aberta ou já em ação
             if (isBackpackOpen || player.isMoving || player.isUsingTool) return;
             if (isContextMenuOpen) closeContextMenu();
             player.path = []; // Movimento manual cancela o caminho do mouse

             const isFacing = (player.lastMoveDir.dx === newDir.dx && player.lastMoveDir.dy === newDir.dy);
             if (!isFacing) {
                 player.lastMoveDir = newDir; 
                 console.log("Turn:", newDir);
             } else {
                 const tX = player.targetX + newDir.dx * TILE_SIZE;
                 const tY = player.targetY + newDir.dy * TILE_SIZE;
                 if (isWalkable(tX, tY)) {
                     player.isMoving = true;
                     player.targetX = tX;
                     player.targetY = tY;
                     console.log("Move:", newDir);
                 } else {
                      console.log("Blocked:", newDir); // Log se o movimento for bloqueado
                 }
             }
         }

         // --- Listeners de Toque (CORRIGIDO) ---
         function handleTouchStart(e) {
             e.preventDefault();
             if (isBackpackOpen || player.isMoving || player.isUsingTool) return; // Bloqueia tudo se mochila aberta ou em ação

             const touch = e.touches[0];
             const rect = canvas.getBoundingClientRect();
             touchStartX = touch.clientX - rect.left;
             touchStartY = touch.clientY - rect.top;
             touchStartTime = Date.now();
             isHolding = false;
             console.log("Touch Start:", touchStartX, touchStartY);

             clearTimeout(touchHoldTimeout);
             touchHoldTimeout = setTimeout(() => {
                 // Verifica novamente se a mochila foi aberta nesse meio tempo
                 if (isBackpackOpen || player.isMoving || player.isUsingTool) return;

                 isHolding = true;
                 const playerScreenX = player.x - camera.x + (player.width / 2);
                 const playerScreenY = player.y - camera.y + (player.height / 2);
                 const diffX = touchStartX - playerScreenX;
                 const diffY = touchStartY - playerScreenY;
                 const absDiffX = Math.abs(diffX);
                 const absDiffY = Math.abs(diffY);

                 if (absDiffX > TOUCH_MOVE_THRESHOLD || absDiffY > TOUCH_MOVE_THRESHOLD) {
                      let moveDir = { dx: 0, dy: 0 };
                     if (absDiffX > absDiffY) { moveDir.dx = Math.sign(diffX); }
                     else { moveDir.dy = Math.sign(diffY); }
                     console.log("Hold detected - Triggering Movement:", moveDir);
                     triggerMovementOrTurn(moveDir);
                 }
             }, TAP_TIME_THRESHOLD);
         }
         function handleTouchMove(e) {
             e.preventDefault();
             if (isBackpackOpen || !isHolding || player.isUsingTool) return; // Ignora se mochila aberta, não for hold, ou usando ferramenta

             // Se está segurando (isHolding = true) E NÃO está se movendo (isMoving = false), tenta iniciar o movimento
             // Se JÁ está se movendo (isMoving = true), não faz nada aqui (deixa o update cuidar)
             if (!player.isMoving) {
                 const playerScreenX = player.x - camera.x + (player.width / 2);
                 const playerScreenY = player.y - camera.y + (player.height / 2);
                 const touch = e.touches[0];
                 const rect = canvas.getBoundingClientRect();
                 const currentX = touch.clientX - rect.left;
                 const currentY = touch.clientY - rect.top;

                 const diffX = currentX - playerScreenX;
                 const diffY = currentY - playerScreenY;
                 const absDiffX = Math.abs(diffX);
                 const absDiffY = Math.abs(diffY);

                 if (absDiffX > TOUCH_MOVE_THRESHOLD || absDiffY > TOUCH_MOVE_THRESHOLD) {
                     let moveDir = { dx: 0, dy: 0 };
                     if (absDiffX > absDiffY) { moveDir.dx = Math.sign(diffX); }
                     else { moveDir.dy = Math.sign(diffY); }
                     console.log("Touch Move (Hold Active) - Triggering Movement:", moveDir);
                     triggerMovementOrTurn(moveDir); // Tenta iniciar/continuar movimento
                 }
            }
         }
         function handleTouchEnd(e) {
             e.preventDefault();
             clearTimeout(touchHoldTimeout); // Limpa o timeout de hold

             if (isBackpackOpen) { isHolding = false; return; } // Ignora se mochila aberta

             const touchDuration = Date.now() - touchStartTime;

             // Se foi rápido e não virou hold -> TAP
             if (!isHolding && touchDuration < TAP_TIME_THRESHOLD) {
                 console.log("Tap detected.");
                  // Ignora se estiver se movendo ou usando ferramenta (pode ter sido iniciado no timeout)
                 if (player.isMoving || player.isUsingTool) {
                     console.log("Tap ignored - player busy.");
                     isHolding = false; // Reset state
                     return;
                 }
 
                 const touchedWorldX = touchStartX + camera.x;
                 const touchedWorldY = touchStartY + camera.y;
                 const touchedTileX = Math.floor(touchedWorldX / TILE_SIZE);
                 const touchedTileY = Math.floor(touchedWorldY / TILE_SIZE);
                 const facingTileX = Math.floor((player.targetX)/TILE_SIZE) + player.lastMoveDir.dx; // Usa targetX
                 const facingTileY = Math.floor((player.targetY)/TILE_SIZE) + player.lastMoveDir.dy; // Usa targetY

                 console.log("Tap Info - Facing:", facingTileX, facingTileY, "Touched:", touchedTileX, touchedTileY);

                 if (touchedTileX === facingTileX && touchedTileY === facingTileY) {
                     console.log("Tap on facing tile - Triggering Use Tool");
                     triggerUseTool();
                 } else {
                     const playerScreenX = player.x - camera.x + (player.width / 2);
                     const playerScreenY = player.y - camera.y + (player.height / 2);
                     const diffX = touchStartX - playerScreenX;
                     const diffY = touchStartY - playerScreenY;
                     const absDiffX = Math.abs(diffX);
                     const absDiffY = Math.abs(diffY);

                     let tapDir = { dx: 0, dy: 0 };
                     if (absDiffX > absDiffY) { tapDir.dx = Math.sign(diffX); }
                     else { tapDir.dy = Math.sign(diffY); }

                     if ((tapDir.dx !== 0 || tapDir.dy !== 0)) {
                         player.lastMoveDir = tapDir;
                         console.log("Tap turn:", tapDir);
                     }
                 }
             } else {
                  console.log("Hold/Drag End.");
                  // Se estava segurando (isHolding=true), o movimento já foi iniciado.
                  // Aqui apenas limpamos o estado. O movimento parará no updatePlayerMovement.
             }

             isHolding = false; // Reseta estado de hold ao soltar
         }

        function findPath(startX, startY, endX, endY, walkableCheckFn = isWalkable) {
            let path = [];
            let currentX = startX;
            let currentY = startY;
            const MAX_STEPS = 100; // Prevenção de loop infinito
            let steps = 0;

            while ((currentX !== endX || currentY !== endY) && steps < MAX_STEPS) {
                const dx = endX - currentX;
                const dy = endY - currentY;
                let nextX = currentX;
                let nextY = currentY;

                if (Math.abs(dx) > Math.abs(dy)) {
                    nextX += Math.sign(dx);
                } else {
                    nextY += Math.sign(dy);
                }

                if (walkableCheckFn(nextX * TILE_SIZE, nextY * TILE_SIZE)) {
                    currentX = nextX;
                    currentY = nextY;
                    path.push({ x: currentX, y: currentY });
                } else {
                    // Tenta mover na outra direção se a principal estiver bloqueada
                    if (Math.abs(dx) > Math.abs(dy)) { // Tentou X, agora tenta Y
                        if (walkableCheckFn(startX * TILE_SIZE, (currentY + Math.sign(dy)) * TILE_SIZE)) {
                             currentY += Math.sign(dy); path.push({ x: currentX, y: currentY });
                        } else break; // Bloqueado
                    } else { // Tentou Y, agora tenta X
                        if (walkableCheckFn((currentX + Math.sign(dx)) * TILE_SIZE, startY * TILE_SIZE)) {
                            currentX += Math.sign(dx); path.push({ x: currentX, y: currentY });
                        } else break; // Bloqueado
                    }
                }
                steps++;
            }
            return path;
        }

        function toggleConstructionMode(forceState = null) {
            if (isContextMenuOpen) closeContextMenu();
            isConstructionModeActive = (forceState !== null) ? forceState : !isConstructionModeActive;

            if (isConstructionModeActive) {
                if (isBackpackOpen) toggleBackpack(false); // Fecha a mochila se estiver aberta
                constructionTargetFloor = player.currentFloor; // Inicializa o andar de construção
                // Não abre o inventário automaticamente, apenas entra no modo
            } else {
                if (isConstructionInventoryOpen) toggleConstructionInventory(false); // Fecha o inventário de construção se estiver aberto
            }

            constructionIcon.classList.toggle('active', isConstructionModeActive);
            updateHotbarUI();
            updateFloorSelectorUI();
        }

        function isActionable(tileX, tileY) {
            const currentMapping = isConstructionModeActive ? constructionHotbarMapping : hotbarMapping;
            const currentSlot = isConstructionModeActive ? activeConstructionHotbarSlot : activeHotbarSlot;
            const bpIdx = currentMapping[currentSlot];
            if (bpIdx < 0 || !backpackInventory[bpIdx]) return false; // Slot vazio
            const item = ITEMS[backpackInventory[bpIdx].id];
            if (!item) return false;

            const targetFloorIndex = isConstructionModeActive ? constructionTargetFloor : player.currentFloor;
            const floorData = worldData[targetFloorIndex];
            if (!floorData) return false;

            const tId = floorData.map[tileY][tileX];
            const objectIndex = floorData.mapObjects.findIndex(obj => obj.x === tileX && obj.y === tileY);

            // Verifica se há um animal no tile
            const animalOnTile = floorData.animals.find(a => tileX >= Math.floor(a.x / TILE_SIZE) && tileX < Math.ceil((a.x + TILE_SIZE) / TILE_SIZE) && tileY >= Math.floor(a.y / TILE_SIZE) && tileY < Math.ceil((a.y + TILE_SIZE) / TILE_SIZE));
            if (animalOnTile) {
                if (item.id === 'shears' && animalOnTile.type === 'sheep' && animalOnTile.woolLevel >= 100 && animalOnTile.age >= 100) return true;
                return false; // Bloqueia outras ações no tile do animal
            }

            if (objectIndex !== -1) {
                const targetObject = floorData.mapObjects[objectIndex];
                if (item.id === 'pickaxe' && targetObject.type === 0) return true;
                if (item.id === 'axe' && targetObject.type === 1) return true;
                if (item.id === 'shovel' && (targetObject.type === 4 || targetObject.type === 15)) return true; // Cerca ou Esqueleto
                // Ação universal de pegar
                if (item.id === 'construction_tool' && player.toolSubAction === 'pickup_mode' && [4, 5, 6, 7, 9, 10, 11].includes(targetObject.type)) return true; // Escadas e telhados podem ser pegos
                // if (targetObject.type === 9 || targetObject.type === 10) return true; // Escadas agora são automáticas
                return false;
            }

            if (tId === 7) return true; // Colheita

            switch (item.id) {
                case 'hoe': return (tId === 0 || tId === 1);
                case 'seed_tomato': return (tId === 2 && backpackInventory[bpIdx].count > 0);
                case 'shovel': return (tId === 1 || tId === 2 || (tId >= 4 && tId <= 7) || tId === 0 || tId === 3 || tId === 8 || tId === 9);
                case 'watering_can': return (tId === 3 || (tId >= 4 && tId <= 6 && backpackInventory[bpIdx].count > 0) || ((tId === 1 || tId === 2) && backpackInventory[bpIdx].count > 0));
                case 'construction_tool':
                    if (player.toolSubAction === 'pickup_mode') { // Pega piso
                        return tId === 8;
                    }
                    if (player.toolSubAction === 'build_floor') {
                        return ((tId === 0 || tId === 1 || tId === 10) && backpackInventory.some(i => i && i.id === 'wood' && i.count > 0));
                    }
                    if (player.toolSubAction === 'build_door' || player.toolSubAction === 'build_gate') {
                        if (player.toolSubAction === 'build_door') {
                            if (tId !== 8) return false; // Portas só em piso
                            const hasMaterial = backpackInventory.some(i => i && i.id === 'door' && i.count > 0) || backpackInventory.some(i => i && i.id === 'wood' && i.count >= 4);
                            const hasAdjacentWall = floorData.mapObjects.some(obj => obj.type === 5 && ( (obj.y === tileY && (obj.x === tileX - 1 || obj.x === tileX + 1)) || (obj.x === tileX && (obj.y === tileY - 1 || obj.y === tileY + 1))));
                            return hasMaterial && hasAdjacentWall;
                        }
                        if (player.toolSubAction === 'build_gate') {
                            if (tId !== 0 && tId !== 1) return false; // Portões em grama/terra
                            const hasMaterial = backpackInventory.some(i => i && i.id === 'gate' && i.count > 0) || backpackInventory.some(i => i && i.id === 'wood' && i.count >= 4);
                            const hasAdjacentFence = floorData.mapObjects.some(obj => obj.type === 4 && ( (obj.y === tileY && (obj.x === tileX - 1 || obj.x === tileX + 1)) || (obj.x === tileX && (obj.y === tileY - 1 || obj.y === tileY + 1))));
                            return hasMaterial && hasAdjacentFence;
                        }
                    }
                    if (player.toolSubAction === 'build_wall') {
                        return ((tId === 0 || tId === 1 || tId === 8) && (backpackInventory.some(i => i && i.id === 'wall' && i.count > 0) || backpackInventory.some(i => i && i.id === 'stone' && i.count >= 5)));
                    }
                    if (player.toolSubAction === 'build_stairs') {
                        const upperFloorIndex = targetFloorIndex + 1;
                        if (tId !== 8) return false; // Precisa ser em piso

                        // Se o andar de cima existir, verifica se está livre. Se não existir, permite a construção (será criado).
                        let isUpperTileFree = true;
                        if (worldData[upperFloorIndex]) {
                            isUpperTileFree = worldData[upperFloorIndex].mapObjects.every(obj => obj.x !== tileX || obj.y !== tileY);
                        }
                        return isUpperTileFree && backpackInventory.some(i => i && i.id === 'wood' && i.count >= 5);
                    }
                    if (player.toolSubAction === 'build_roof') {
                        if (!backpackInventory.some(i => i && i.id === 'clay' && i.count >= 1)) return false;
                        const lowerFloorIndex = targetFloorIndex - 1;
                        if (lowerFloorIndex < 0) return false; // Não pode no térreo

                        const lowerFloor = worldData[lowerFloorIndex];
                        if (!lowerFloor) return false;

                        return lowerFloor.map[tileY][tileX] !== 10 || lowerFloor.mapObjects.some(obj => obj.x === tileX && obj.y === tileY);
                    }
                    if (player.toolSubAction === 'build_fence') {
                        return ((tId === 0 || tId === 1) && (backpackInventory.some(i => i && i.id === 'fence' && i.count > 0) || backpackInventory.some(i => i && i.id === 'wood' && i.count > 0)));
                    }
            }

            return false;
        }

        function handleCanvasClick(event) {
            // Ignora o clique se a mochila estiver aberta ou o jogador estiver ocupado
            if (isBackpackOpen || isConstructionInventoryOpen || player.isMoving || player.isUsingTool) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left; // Corrigido
            const clickY = event.clientY - rect.top;

            const worldX = clickX + camera.x;
            const worldY = clickY + camera.y;

            const clickedTileX = Math.floor(worldX / TILE_SIZE);
            const clickedTileY = Math.floor(worldY / TILE_SIZE);

            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);

            const dist = Math.sqrt(Math.pow(playerTileX - clickedTileX, 2) + Math.pow(playerTileY - clickedTileY, 2));

            // Permite o uso se a distância for pequena (adjacente ou diagonal)
            if (dist < 1.5) {
                const floorData = worldData[player.currentFloor]; // Corrigido
                // 1. Prioriza a ação da ferramenta
                if (isActionable(clickedTileX, clickedTileY)) {
                    triggerUseTool({ x: clickedTileX, y: clickedTileY });
                } else {
                    // 2. Se não houver ação da ferramenta, verifica se é uma porta/porteira para abrir/fechar
                    const objectIndex = floorData.mapObjects.findIndex(obj => obj.x === clickedTileX && obj.y === clickedTileY && (obj.type === 6 || obj.type === 7));
                    if (objectIndex === -1) return; // Não faz nada se não for porta/porteira
                const targetObject = worldData[player.currentFloor].mapObjects[objectIndex];
                    targetObject.isOpen = !targetObject.isOpen;
                    console.log(`${targetObject.type === 6 ? 'Porta' : 'Porteira'} ${targetObject.isOpen ? 'aberta' : 'fechada'}.`);
                    saveGame();
                }
            } else {
                // Se for um tile caminhável, encontra um caminho
                if (isWalkable(clickedTileX * TILE_SIZE, clickedTileY * TILE_SIZE)) {
                    if (isContextMenuOpen) closeContextMenu();
                    player.path = findPath(playerTileX, playerTileY, clickedTileX, clickedTileY);
                }
            }
        }

        function handleCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const moveX = event.clientX - rect.left;
            const moveY = event.clientY - rect.top;

            // Posiciona o ícone flutuante
            mouseIcon.style.left = `${moveX - 16}px`; // Centraliza o ícone no cursor
            mouseIcon.style.top = `${moveY - 16}px`;
            mouseIcon.className = ''; // Limpa classes anteriores

            if (isBackpackOpen) {
                mouseHoverTile.x = null;
                mouseHoverTile.y = null;
                mouseIcon.style.display = 'none';
                return;
            }

            mouseIcon.style.display = 'block';
            const worldX = moveX + camera.x;
            const worldY = moveY + camera.y;
            mouseHoverTile.x = Math.floor(worldX / TILE_SIZE);
            mouseHoverTile.y = Math.floor(worldY / TILE_SIZE);

            // Calcula distância e verifica se o tile é válido
            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);
            const dist = Math.sqrt(Math.pow(playerTileX - mouseHoverTile.x, 2) + Math.pow(playerTileY - mouseHoverTile.y, 2));

            // Se for uma ação de construção, o preview já é o cursor.
            if (isConstructionModeActive && player.toolSubAction && player.toolSubAction !== 'pickup_mode' && isActionable(mouseHoverTile.x, mouseHoverTile.y)) {
                mouseIcon.style.display = 'none';
                return;
            }

            // Oculta o cursor se a pré-visualização de plantação estiver ativa
            const bpIdx = hotbarMapping[activeHotbarSlot];
            if (bpIdx !== -1 && backpackInventory[bpIdx]) {
                const item = ITEMS[backpackInventory[bpIdx].id];
                if (item && item.id.startsWith('seed_') && isActionable(mouseHoverTile.x, mouseHoverTile.y)) {
                    mouseIcon.style.display = 'none';
                    return;
                }
            }


            if (dist < 1.5) { // Alcance de interação
                if (isActionable(mouseHoverTile.x, mouseHoverTile.y)) {
                    mouseIcon.classList.add('cursor-action');
                } else {
                    mouseIcon.classList.add('cursor-invalid');
                }
            } else { // Fora do alcance de interação
                if (isWalkable(mouseHoverTile.x * TILE_SIZE, mouseHoverTile.y * TILE_SIZE)) {
                    mouseIcon.classList.add('cursor-walk');
                } else {
                    mouseIcon.classList.add('cursor-invalid');
                }
            }
        }

        function handleCanvasMouseLeave() {
            mouseHoverTile.x = null;
            mouseHoverTile.y = null;
            if (mouseIcon) {
                mouseIcon.style.display = 'none';
            }
        }

        function generateWaterSpritesheet() {
            const NUM_FRAMES = 8;
            waterSpritesheetCanvas.width = TILE_SIZE * NUM_FRAMES;
            waterSpritesheetCanvas.height = TILE_SIZE;

            for (let i = 0; i < NUM_FRAMES; i++) {
                const x = i * TILE_SIZE;
                const y = 0;
                
                // Base
                waterSpritesheetCtx.fillStyle = '#1976D2';
                waterSpritesheetCtx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                // Highlights animados
                waterSpritesheetCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                const yOffset1 = Math.sin((i / NUM_FRAMES) * Math.PI * 2) * 3;
                const yOffset2 = Math.cos((i / NUM_FRAMES) * Math.PI * 2) * 2;
                waterSpritesheetCtx.fillRect(x + 5, y + 8 + yOffset1, 10, 4);
                waterSpritesheetCtx.fillRect(x + 18, y + 20 - yOffset1, 8, 3);
                waterSpritesheetCtx.fillRect(x + 10, y + 15 + yOffset2, 6, 3);
            }
            console.log("Spritesheet de água gerado.");
        }

        function generateCampfireSpritesheet() {
            const NUM_FRAMES = 8;
            campfireSpritesheetCanvas.width = TILE_SIZE * NUM_FRAMES;
            campfireSpritesheetCanvas.height = TILE_SIZE;
            const frameDuration = 150; // Duração simulada para capturar a animação

            for (let i = 0; i < NUM_FRAMES; i++) {
                const x = i * TILE_SIZE;
                const simulatedTimestamp = i * frameDuration;
                // A função drawCampfire desenha relativo ao x,y que passamos
                drawCampfire(campfireSpritesheetCtx, x, 0, simulatedTimestamp);
            }
            console.log("Spritesheet de fogueira gerado.");
        }

        function generateTorchSpritesheet() {
            const NUM_FRAMES = 8;
            torchSpritesheetCanvas.width = TILE_SIZE * NUM_FRAMES;
            torchSpritesheetCanvas.height = TILE_SIZE;
            const frameDuration = 150; // Duração simulada para capturar a animação

            for (let i = 0; i < NUM_FRAMES; i++) {
                const x = i * TILE_SIZE;
                const simulatedTimestamp = i * frameDuration;
                // A função drawTorch desenha relativo ao x,y que passamos
                drawTorch(torchSpritesheetCtx, x, 0, simulatedTimestamp);
            }
            console.log("Spritesheet de tocha gerado.");
        }

        // --- Inicialização ---
        function init() {
            backpackIcon = document.getElementById('backpackIcon');
            if (!backpackIcon) { console.error("Ícone da mochila não encontrado!"); return; }
            timeRangeSlider = document.getElementById('timeRangeSlider');
            if (!timeRangeSlider) { console.error("Slider de tempo não encontrado!"); return; }
            itemTooltip = document.getElementById('itemTooltip');
            if (!itemTooltip) { console.error("Elemento do tooltip não encontrado!"); return; }
            mouseIcon = document.getElementById('mouseIcon');
            if (!mouseIcon) { console.error("Elemento do ícone do mouse não encontrado!"); return; }
            constructionContainer = document.getElementById('constructionContainer');
            if (!constructionContainer) { console.error("Container de construção não encontrado!"); return; }
            constructionIcon = document.getElementById('constructionIcon');
            if (!constructionIcon) { console.error("Ícone de construção não encontrado!"); return; }
            contextMenu = document.getElementById('contextMenu');
            floorSelectorLabel = document.querySelector('#floorSelector span');
            floorUpBtn = document.getElementById('floorUpBtn');
            floorDownBtn = document.getElementById('floorDownBtn');

            if (!contextMenu) { console.error("Elemento do menu de contexto não encontrado!"); return; }

            loadGame();
            generateWaterSpritesheet();
            generateCampfireSpritesheet();
            generateTorchSpritesheet();
            updateHotbarUI();
            startGrowthTimer();

            // Loop do Relógio
            updateGameTime(); drawGameClock(); updateNightOverlay();
            setInterval(() => { updateGameTime(); drawGameClock(); updateNightOverlay(); }, 1000);
            setInterval(saveGame, 30000); // Salva o jogo a cada 30 segundos

            // Listener de clique do ÍCONE da Mochila
            backpackIcon.addEventListener('click', () => {
                if (isConstructionModeActive) toggleConstructionMode(false); // Sai do modo construção
                toggleBackpack(); // Abre/fecha a mochila
            });
            constructionIcon.addEventListener('click', () => {
                if (!isConstructionModeActive) toggleConstructionMode(true); // Entra no modo construção
                toggleConstructionInventory(); // Abre/fecha o inventário de construção
            });

            // Listeners do Seletor de Andar
            floorUpBtn.addEventListener('click', () => changeConstructionFloor(1));
            floorDownBtn.addEventListener('click', () => changeConstructionFloor(-1));

            // Listeners da HOTBAR
            hotbarElement.querySelectorAll('.slot').forEach(slotElement => {
                slotElement.addEventListener('click', handleHotbarSlotClick);
                // Listener para abrir menu de contexto com o botão direito
                slotElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // Previne o menu padrão do navegador
                    if (isBackpackOpen) return;
                    const hotbarIndex = parseInt(e.currentTarget.dataset.hotbarIndex, 10);
                    openContextMenu(hotbarIndex);
                });
                
                // Listeners de Drag & Drop
                slotElement.addEventListener('dragstart', handleDragStart);
                slotElement.addEventListener('dragover', handleDragOver);
                slotElement.addEventListener('dragleave', handleDragLeave);
                slotElement.addEventListener('drop', handleDrop);
                slotElement.addEventListener('dragend', handleDragEnd);
                // Adiciona listeners para o tooltip
                slotElement.addEventListener('mouseover', showTooltip);
                slotElement.addEventListener('mouseout', hideTooltip);
            });

            // Listener do Slider de Tempo
            timeRangeSlider.addEventListener('input', (e) => {
                const targetHour = parseInt(e.target.value, 10);
                const n = new Date();
                const currentRealHour = n.getHours();
                // Calcula o offset necessário para que a hora do jogo seja a hora alvo
                gameTimeOffset = (targetHour - currentRealHour + 24) % 24;
                updateGameTime();
                drawGameClock();
                updateNightOverlay();
            });

            // Adiciona Listeners de Toque ao Canvas
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false }); // Trata cancelamento como touchend
            canvas.addEventListener('click', handleCanvasClick);
            // Fecha o menu de contexto se clicar em qualquer lugar fora dele
            document.addEventListener('click', (e) => {
                // Lógica para fechar os inventários ao clicar fora
                const isClickOnHotbar = hotbarElement.contains(e.target);

                // Só fecha se o clique for fora do container E não for um clique na hotbar para atribuir um item
                if (isConstructionInventoryOpen && !constructionContainer.contains(e.target) && e.target !== constructionIcon && !(isClickOnHotbar && selectedConstructionIndex !== -1)) {
                    toggleConstructionInventory(false);
                }
                if (isBackpackOpen && !backpackContainer.contains(e.target) && e.target !== backpackIcon && !(isClickOnHotbar && selectedBackpackIndex !== -1)) {
                    toggleBackpack(false);
                }

                if (isContextMenuOpen && !contextMenu.contains(e.target) && !hotbarElement.contains(e.target)) { // Mantém a lógica do menu de contexto
                    closeContextMenu();
                }
            });
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseleave', handleCanvasMouseLeave);


            requestAnimationFrame(gameLoop);
        }

        function changeFloor(stair) {
            console.log(`Mudando do andar ${player.currentFloor} para ${stair.targetFloor}`);
            
            let landingDir = { dx: 0, dy: 0 };
            // A direção de aterrissagem é baseada no tipo da escada, não na direção do jogador
            if (stair.type === 9) { // Escada para Cima
                landingDir.dy = -1; // Aterrissa um tile para "cima" (norte) no mapa
            } else if (stair.type === 10) { // Escada para Baixo
                landingDir.dy = 1;  // Aterrissa um tile para "baixo" (sul) no mapa
            }

            // Calcula a posição final com base na direção da escada
            const finalX = (stair.targetX + landingDir.dx) * TILE_SIZE;
            const finalY = (stair.targetY + landingDir.dy) * TILE_SIZE;

            player.currentFloor = stair.targetFloor;
            player.x = finalX;
            player.y = finalY;
            player.targetX = finalX;
            player.targetY = finalY;
            player.path = []; // Limpa o caminho para evitar movimentos indesejados
            preRenderMap(); // Re-renderiza o mapa do novo andar
        }

        function changeConstructionFloor(direction) {
            const newFloor = constructionTargetFloor + direction;
            // Se o andar alvo existir, muda para ele.
            if (worldData[newFloor]) {
                constructionTargetFloor = newFloor;
                updateFloorSelectorUI();
            } else if (direction > 0 && newFloor === worldData.length) {
                // Se estiver a tentar subir para um andar que ainda não existe, cria-o.
                worldData[newFloor] = createNewFloorData(createEmptyFloorLayout(), []);
                constructionTargetFloor = newFloor;
                updateFloorSelectorUI();
            }
        }

        function updateFloorSelectorUI() {
            if (floorSelectorLabel) {
                floorSelectorLabel.textContent = `Andar: ${constructionTargetFloor}`;
            }
        }

        function triggerResourceFeedback(quantity, resourceName) {
            const isGain = quantity > 0;
            activeAnimations.push({
                type: 'resource_feedback',
                text: `${isGain ? '+' : ''}${quantity}`,
                color: isGain ? '144, 238, 144' : '255, 99, 71', // Verde claro ou Tomate
                x: player.x + player.width / 2,
                y: player.y,
                startTime: lastTime,
                duration: 1500
            });
            console.log(`Feedback: ${quantity} ${resourceName}`);
        }

        document.addEventListener('DOMContentLoaded', init);


    </script>
</body>
</html>
