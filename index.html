<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Farm Game</title>
    <style>
        body {
            font-family: 'Consolas', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            color: white;
            overflow: hidden; 
        }

        h1 {
            margin-bottom: 15px; 
            font-weight: normal;
        }

        p {
            margin-top: 10px; 
            margin-bottom: 10px; 
            font-size: 0.9em;
        }

        /* Estilo da Janela do Jogo - RESTAURADO */
        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
            
            background-color: #000;
            border: 2px solid #555;
            border-radius: 10px;
            /* Restaurando a sombra e brilho anteriores */
            box-shadow: 0 0 15px rgba(150, 150, 255, 0.5), 
                        inset 0 0 10px rgba(0, 0, 0, 0.5); 
            padding: 2px; /* RESTAURADO: Adiciona padding para a borda interna */
            overflow: hidden; 
        }

        /* Canvas e overlays agora ajustados ao padding do container */
        canvas, #nightOverlay, #lightCanvas {
            position: absolute;
            top: 2px; 
            left: 2px; 
            image-rendering: pixelated; 
            width: calc(100% - 4px); /* Considera o padding */ 
            height: calc(100% - 4px); /* Considera o padding */
            border-radius: 8px; 
        }
        
        #nightOverlay {
            background-color: #000033; 
            opacity: 0; 
            z-index: 5; 
            pointer-events: none; 
            transition: opacity 1s linear; 
        }

        #lightCanvas {
            z-index: 6; /* Acima do nightOverlay */
            pointer-events: none;
        }

        /* Inventário de volta para dentro do container */
        #inventoryBar {
            position: absolute; /* RESTAURADO */
            bottom: 10px;      /* RESTAURADO */
            left: 50%;         /* RESTAURADO */
            transform: translateX(-50%); /* RESTAURADO */
            /* margin-top: 10px; */ /* REMOVIDO */
            display: flex;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            padding: 5px;
            border-radius: 8px;
            z-index: 10; /* RESTAURADO */
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #888;
            background-color: #444;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            position: relative; 
            cursor: pointer;
            user-select: none; 
        }

        .slot.active {
            background-color: #666;
            border-color: #FFF;
            box-shadow: 0 0 10px #FFF;
        }
        
        .slot-name {
            font-weight: bold;
            font-size: 11px;
            text-shadow: 1px 1px #000;
        }
        
        .slot-count {
            margin-top: 3px;
            font-size: 14px;
            color: #FFD700; 
            font-weight: bold;
        }

        .slot-key {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 10px;
            color: #AAA;
            font-weight: bold;
        }

        #gameClock {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10; 
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px #000;
            display: flex; 
            align-items: center;
            gap: 5px; 
        }

        .time-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: transparent;
            flex-shrink: 0;
        }

        #gameClock span {
            line-height: 1; 
        }

        #timeToggleButton {
             margin-top: 5px; 
             padding: 5px 10px; 
             font-family: 'Consolas', monospace; 
             cursor: pointer;
             background-color: #555;
             color: white;
             border: 1px solid #888;
             border-radius: 5px;
        }
        #timeToggleButton:hover {
            background-color: #777;
        }

    </style>
</head>
<body>
    <h1>Mini Fazenda Pixelada</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas">
            Seu navegador não suporta o elemento Canvas.
        </canvas>
        
        <div id="nightOverlay"></div>
        <canvas id="lightCanvas"></canvas> 
        <div id="gameClock">
            <canvas id="timeIconCanvas" class="time-icon" width="20" height="20"></canvas>
            <span>00:00</span>
        </div>
        <!-- Inventário MOVIDO de volta para DENTRO do gameContainer -->
        <div id="inventoryBar">
            <div class="slot" data-index="0">
                <span class="slot-key">1</span>
                <span class="slot-name">Enxada</span>
                <span class="slot-count">1</span>
            </div>
            <div class="slot" data-index="1">
                <span class="slot-key">2</span>
                <span class="slot-name">Semente</span>
                <span class="slot-count">10</span>
            </div>
            <div class="slot" data-index="2">
                <span class="slot-key">3</span>
                <span class="slot-name">Colheita</span>
                <span class="slot-count">0</span>
            </div>
            <div class="slot" data-index="3">
                <span class="slot-key">4</span>
                <span class="slot-name">Pá</span>
                <span class="slot-count">1</span>
            </div>
            <div class="slot" data-index="4">
                <span class="slot-key">5</span>
                <span class="slot-name">Regador</span>
                <span class="slot-count">0</span>
            </div>
            <div class="slot" data-index="5">
                <span class="slot-key">6</span>
                <span class="slot-name"></span>
                <span class="slot-count"></span>
            </div>
            <div class="slot" data-index="6">
                <span class="slot-key">7</span>
                <span class="slot-name"></span>
                <span class="slot-count"></span>
            </div>
        </div>

    </div>
    
    <p>Setas para mover (toque para virar, segure para andar). Espaço para usar. 1-7 para inventário.</p>
    <button id="timeToggleButton">Avançar 12h (Teste)</button>


    <script>
        // --- Configurações Iniciais ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameClockSpan = document.querySelector('#gameClock span'); 
        const timeIconCanvas = document.getElementById('timeIconCanvas'); 
        const timeIconCtx = timeIconCanvas.getContext('2d');
        const nightOverlay = document.getElementById('nightOverlay'); 
        
        const lightCanvas = document.getElementById('lightCanvas');
        const lightCtx = lightCanvas.getContext('2d');

        ctx.imageSmoothingEnabled = false; 
        timeIconCtx.imageSmoothingEnabled = false; 
        lightCtx.imageSmoothingEnabled = false; 

        const zoomLevel = 1; 
        
        // Ajuste do tamanho do canvas para corresponder ao container COM PADDING
        canvas.width = (640 - 4) / zoomLevel; 
        canvas.height = (480 - 4) / zoomLevel; 
        lightCanvas.width = canvas.width; 
        lightCanvas.height = canvas.height;


        // --- Configurações do Jogo ---
        const TILE_SIZE = 32;
        const GROWTH_TIME_SPROUT = 60000;  // 1 minuto
        const GROWTH_TIME_PLANT = 120000;   // 2 minutos
        const GROWTH_TIME_HARVEST = 180000; // 3 minutos
        const TOOL_ANIM_DURATION = 150; 

        // --- Estado do Jogo ---
        let player = {
            x: 11 * TILE_SIZE,
            y: 11 * TILE_SIZE,
            width: 20,
            height: 28,
            colorHead: '#FFDAB9',
            colorBody: '#007BFF',
            colorLegs: '#0056B3',
            speed: 2,
            isMoving: false,
            targetX: 11 * TILE_SIZE,
            targetY: 11 * TILE_SIZE,
            walkBob: 0,
            walkBobSpeed: 0.15,
            isUsingTool: false,
            toolAnimStart: 0, 
            lastMoveDir: { dx: 0, dy: 1 } 
        };

        let camera = {
            x: 0,
            y: 0
        };

        // 0=Grama, 1=Terra, 2=Arado, 3=Água, 4=Semente, 5=Muda, 6=Planta, 7=Colheita
        let map = [
            [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 3, 3, 0, 0, 0, 0, 0, 1, 2, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 3, 3, 0, 3, 0, 0, 1, 2, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 3, 3, 3, 3, 0, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 3, 3, 3, 3, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];
        const MAP_WIDTH_TILES = map[0].length;
        const MAP_HEIGHT_TILES = map.length;
        const MAP_WIDTH_PX = MAP_WIDTH_TILES * TILE_SIZE;
        const MAP_HEIGHT_PX = MAP_HEIGHT_TILES * TILE_SIZE;

        // { "x,y": { plantedAt: timestamp, boosted: true/false } }
        let plantGrowthData = {};
        
        // NOVO: Objetos do Mapa (Árvores, Pedras, Fogueiras, Tochas)
        // type: 0=Rocha, 1=Árvore, 2=Fogueira, 3=Tocha
        // x, y são posições de TILE
        let mapObjects = [
            // Árvores (garantir que x,y não caiam em tile 3 no 'map' acima)
            { type: 1, x: 4, y: 7 }, 
            { type: 1, x: 6, y: 10 },
            { type: 1, x: 18, y: 8 },
            { type: 1, x: 20, y: 12 },
            { type: 1, x: 22, y: 5 }, 
            // Pedras (garantir que x,y não caiam em tile 3 no 'map' acima)
            { type: 0, x: 5, y: 8 }, 
            { type: 0, x: 19, y: 6 }, 
            { type: 0, x: 21, y: 11 },
            { type: 0, x: 23, y: 14 },
            { type: 0, x: 17, y: 13 },
            // Fogueiras
            { type: 2, x: 13, y: 12 }, 
            { type: 2, x: 8, y: 18 },
            // Tochas (idealmente em bordas de grama/terra)
            { type: 3, x: 16, y: 1 }, 
            { type: 3, x: 1, y: 15 },
            { type: 3, x: 23, y: 1 },
            { type: 3, x: 12, y: 24 },
        ];


        let inventory = [
            { name: "Enxada", count: 1 },
            { name: "Semente", count: 10 },
            { name: "Colheita", count: 0 },
            { name: "Pá", count: 1 },
            { name: "Regador", count: 0 }, 
            null, 
            null  
        ];
        let activeSlot = 0; 

        let activeAnimations = [];

        // --- Variáveis de Tempo ---
        let gameHour = 0;
        let gameMinute = 0;
        let gameTimeOffset = 0;
        const GAME_MINUTES_PER_DAY = 1440;
        const REAL_SECONDS_PER_GAME_DAY = 3600;
        
        const preRenderedMapCanvas = document.createElement('canvas');
        preRenderedMapCanvas.width = MAP_WIDTH_PX;
        preRenderedMapCanvas.height = MAP_HEIGHT_PX;
        const preRenderedMapCtx = preRenderedMapCanvas.getContext('2d');
        preRenderedMapCtx.imageSmoothingEnabled = false;

        // --- Funções de Desenho dos Tiles (Chão) ---
        function drawGrassTile(ctx, x, y, size) {
            ctx.fillStyle = '#558B2F';
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            const pixelSize = 4;
            for (let ty = 0; ty < size; ty += pixelSize * 2) {
                for (let tx = 0; tx < size; tx += pixelSize * 2) {
                     ctx.fillRect(x + tx, y + ty, pixelSize, pixelSize);
                     ctx.fillRect(x + tx + pixelSize, y + ty + pixelSize, pixelSize, pixelSize);
                }
            }
        }
        function drawEarthTile(ctx, x, y, size) {
            ctx.fillStyle = '#8D6E63';
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(x + 5, y + 10, 4, 4);
            ctx.fillRect(x + 15, y + 25, 4, 4);
            ctx.fillRect(x + 22, y + 8, 4, 4);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fillRect(x + 8, y + 20, 3, 3);
            ctx.fillRect(x + 18, y + 5, 3, 3);
            ctx.fillRect(x + 25, y + 15, 3, 3);
        }
        function drawPlowedTile(ctx, x, y, size) {
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = '#A1887F';
            const furrowHeight = 4;
            const spacing = 10;
            for (let fy = 2; fy < size; fy += spacing) {
                ctx.fillRect(x, y + fy, size, furrowHeight);
            }
        }
        function drawWaterTile(ctx, x, y, size) {
            ctx.fillStyle = '#1976D2';
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(x + 5, y + 8, 10, 4);
            ctx.fillRect(x + 18, y + 20, 8, 4);
            ctx.fillRect(x + 10, y + 15, 6, 3);
        }
        function drawSeedTile(ctx, x, y, size) {
            drawPlowedTile(ctx, x, y, size);
            ctx.fillStyle = '#A1887F';
            ctx.fillRect(x + 8, y + 6, 3, 3);
            ctx.fillRect(x + 20, y + 16, 3, 3);
            ctx.fillRect(x + 12, y + 26, 3, 3);
        }
        function drawSproutTile(ctx, x, y, size) {
            drawPlowedTile(ctx, x, y, size);
            ctx.fillStyle = '#8BC34A';
            ctx.fillRect(x + 13, y + 10, 6, 8);
            ctx.fillRect(x + 15, y + 8, 2, 4);
        }
        function drawPlantTile(ctx, x, y, size) {
            drawPlowedTile(ctx, x, y, size);
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(x + 12, y + 8, 8, 16);
            ctx.fillRect(x + 8, y + 12, 4, 8);
            ctx.fillRect(x + 20, y + 12, 4, 8);
        }
        function drawHarvestableTile(ctx, x, y, size) {
            drawPlowedTile(ctx, x, y, size);
            ctx.fillStyle = '#388E3C';
            ctx.fillRect(x + 10, y + 5, 12, 22);
            ctx.fillRect(x + 6, y + 10, 4, 12);
            ctx.fillRect(x + 22, y + 10, 4, 12);
            ctx.fillStyle = '#E53935';
            ctx.fillRect(x + 14, y + 14, 4, 4); 
            ctx.fillRect(x + 10, y + 18, 4, 4);
            ctx.fillRect(x + 18, y + 18, 4, 4);
        }
        
        // --- Funções de Desenho de OBJETOS ---
        function drawRock(ctx, x_px, y_px) {
            const y_base = y_px + TILE_SIZE; 
            
            // Sombra já tratada no Y-Sort
            // ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            // ...

            ctx.fillStyle = '#795548'; 
            ctx.fillRect(x_px + 4, y_px + 10, 24, 18);
            ctx.fillStyle = '#8D6E63';
            ctx.fillRect(x_px + 6, y_px + 12, 20, 14);
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(x_px + 18, y_px + 15, 6, 6);
            ctx.fillRect(x_px + 8, y_px + 20, 8, 8);
        }

        function drawTreeTrunk(ctx, x_px, y_px) {
            // Sombra já tratada no Y-Sort
            // const y_base = y_px + TILE_SIZE; 
            // ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            // ...

            ctx.fillStyle = '#5D4037'; 
            ctx.fillRect(x_px + 12, y_px + 16, 8, TILE_SIZE - 16); // Tronco até a base
            ctx.fillStyle = '#795548';
            ctx.fillRect(x_px + 13, y_px + 17, 6, TILE_SIZE - 18);
        }

        function drawTreeCanopy(ctx, x_px, y_px) {
            const y_canopy_top = y_px - TILE_SIZE * 1.5 + 8; // Ajusta o y para ficar mais para cima
            const x_canopy_center = x_px + TILE_SIZE / 2;
            
            // Sombra já tratada no Y-Sort
            // ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            // ...
            
            ctx.fillStyle = '#388E3C'; 
            ctx.beginPath();
            ctx.ellipse(x_canopy_center, y_canopy_top + TILE_SIZE * 0.8, TILE_SIZE * 1.1, TILE_SIZE * 0.9, 0, 0, Math.PI * 2);
            ctx.ellipse(x_canopy_center - TILE_SIZE * 0.5, y_canopy_top + TILE_SIZE * 1.2, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(x_canopy_center + TILE_SIZE * 0.5, y_canopy_top + TILE_SIZE * 1.2, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#4CAF50'; 
            ctx.beginPath();
            ctx.ellipse(x_canopy_center, y_canopy_top + TILE_SIZE * 0.7, TILE_SIZE * 0.8, TILE_SIZE * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(x_canopy_center - TILE_SIZE * 0.4, y_canopy_top + TILE_SIZE * 1.0, TILE_SIZE * 0.6, TILE_SIZE * 0.5, 0, 0, Math.PI * 2);
            ctx.ellipse(x_canopy_center + TILE_SIZE * 0.4, y_canopy_top + TILE_SIZE * 1.0, TILE_SIZE * 0.6, TILE_SIZE * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCampfire(ctx, x_px, y_px, timestamp) {
            const y_base = y_px + TILE_SIZE; 

            // Pedras da fogueira
            ctx.fillStyle = '#A1887F'; 
            ctx.fillRect(x_px + 10, y_px + 20, 4, 6);
            ctx.fillRect(x_px + 18, y_px + 22, 4, 6);
            ctx.fillRect(x_px + 14, y_px + 24, 6, 4);

            // Troncos
            ctx.fillStyle = '#795548'; 
            ctx.fillRect(x_px + 12, y_px + 21, 8, 2);
            ctx.fillRect(x_px + 12, y_px + 23, 8, 2);

            // Chamas (animadas)
            const flameHue = (Math.sin(timestamp * 0.005) * 0.1 + 0.9) * 30; 
            const flameSizeVar = Math.sin(timestamp * 0.003) * 1 + 3; 

            ctx.fillStyle = `hsl(${flameHue}, 100%, 50%)`; 
            ctx.fillRect(x_px + 14, y_px + 16 - flameSizeVar, 4, 4 + flameSizeVar);
            ctx.fillStyle = `hsl(${flameHue + 10}, 100%, 60%)`; 
            ctx.fillRect(x_px + 12, y_px + 18 - flameSizeVar / 2, 4, 4 + flameSizeVar / 2);
            ctx.fillRect(x_px + 18, y_px + 18 - flameSizeVar / 2, 4, 4 + flameSizeVar / 2);

            // Fumaça (pequenos puffs)
            const smokeOffset = (timestamp * 0.001) % (TILE_SIZE / 2);
            ctx.fillStyle = `rgba(180, 180, 180, ${0.3 - (smokeOffset / (TILE_SIZE / 2)) * 0.3})`;
            ctx.fillRect(x_px + 15, y_px + 10 - smokeOffset, 2, 2);
            ctx.fillRect(x_px + 17, y_px + 8 - smokeOffset * 1.5, 2, 2);
        }

        function drawTorch(ctx, x_px, y_px, timestamp) {
            const torchX = x_px + TILE_SIZE / 2 - 2; 
            const torchY = y_px + TILE_SIZE / 2; 

            // Haste da tocha
            ctx.fillStyle = '#795548'; 
            ctx.fillRect(torchX, torchY, 4, 10);

            // Base de metal
            ctx.fillStyle = '#A0A0A0'; 
            ctx.fillRect(torchX - 1, torchY - 2, 6, 2);

            // Chamas (animadas, menor que a fogueira)
            const flameHue = (Math.sin(timestamp * 0.007) * 0.1 + 0.9) * 30; 
            const flameSizeVar = Math.sin(timestamp * 0.004) * 0.5 + 1.5;

            ctx.fillStyle = `hsl(${flameHue}, 100%, 50%)`; 
            ctx.fillRect(torchX + 1, torchY - 6 - flameSizeVar, 2, 4 + flameSizeVar);
            ctx.fillStyle = `hsl(${flameHue + 10}, 100%, 60%)`; 
            ctx.fillRect(torchX, torchY - 4 - flameSizeVar / 2, 4, 2 + flameSizeVar / 2);
        }
        
        // --- Funções de Renderização ---
        function preRenderMap() {
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    const tileId = map[y][x];
                    updatePreRenderedTile(x, y, tileId);
                }
            }
            console.log("Mapa pré-renderizado!");
        }

        function updatePreRenderedTile(tileX, tileY, tileId) {
            const drawX = tileX * TILE_SIZE;
            const drawY = tileY * TILE_SIZE;
            switch(tileId) {
                case 0: drawGrassTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 1: drawEarthTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 2: drawPlowedTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 3: drawWaterTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 4: drawSeedTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 5: drawSproutTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 6: drawPlantTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                case 7: drawHarvestableTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE); break;
                default:
                    drawGrassTile(preRenderedMapCtx, drawX, drawY, TILE_SIZE);
            }
        }

        function drawPlayer(timestamp) { 
            const px = player.x;
            const py = player.y;
            const w = player.width;
            const h = player.height;
            
            let finalBob = 0;
            if (player.isMoving) {
                finalBob = Math.sin(player.walkBob) * 2;
            } else if (player.isUsingTool) {
                const animProgress = (timestamp - player.toolAnimStart) / TOOL_ANIM_DURATION;
                finalBob = Math.abs(Math.sin(animProgress * Math.PI)) * 6;
            }
            const bobH = py + finalBob;
            
            // Sombra é desenhada separadamente com Y-Sort
            // ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            // ...

            ctx.fillStyle = player.colorLegs;
            ctx.fillRect(px, bobH + h * 0.6, w * 0.45, h * 0.4);
            ctx.fillRect(px + w * 0.55, bobH + h * 0.6, w * 0.45, h * 0.4);

            ctx.fillStyle = player.colorBody;
            ctx.fillRect(px, bobH + h * 0.3, w, h * 0.4);

            const headX = px + w * 0.1;
            const headY = bobH;
            const headW = w * 0.8;
            const headH = h * 0.4;
            ctx.fillStyle = player.colorHead;
            ctx.fillRect(headX, headY, headW, headH);

            ctx.fillStyle = '#000';
            const eyeSize = 2;
            let eye1_x, eye1_y, eye2_x, eye2_y;

            if (player.lastMoveDir.dy === 1) { // Baixo
                eye1_x = headX + headW * 0.25;
                eye1_y = headY + headH * 0.6;
                eye2_x = headX + headW * 0.75 - eyeSize;
                eye2_y = headY + headH * 0.6;
            } else if (player.lastMoveDir.dy === -1) { // Cima
                eye1_x = headX + headW * 0.25;
                eye1_y = headY + headH * 0.2;
                eye2_x = headX + headW * 0.75 - eyeSize;
                eye2_y = headY + headH * 0.2;
            } else if (player.lastMoveDir.dx === -1) { // Esquerda
                eye1_x = headX + headW * 0.2;
                eye1_y = headY + headH * 0.4;
                eye2_x = headX + headW * 0.5 - eyeSize;
                eye2_y = headY + headH * 0.4;
            } else if (player.lastMoveDir.dx === 1) { // Direita
                eye1_x = headX + headW * 0.5;
                eye1_y = headY + headH * 0.4;
                eye2_x = headX + headW * 0.8 - eyeSize;
                eye2_y = headY + headH * 0.4;
            }
            
            if (eye1_x) {
                ctx.fillRect(eye1_x, eye1_y, eyeSize, eyeSize);
                ctx.fillRect(eye2_x, eye2_y, eyeSize, eyeSize);
            }
        }
        
        function drawWaterAnimation(anim, timestamp) { 
            const elapsed = timestamp - anim.startTime;
            const progress = elapsed / anim.duration;
            if (progress > 1) return;

            const x = anim.x * TILE_SIZE + TILE_SIZE / 2;
            const y = anim.y * TILE_SIZE + TILE_SIZE / 2;

            for (let i = 0; i < 5; i++) {
                const angle = i * (Math.PI * 2 / 5) + progress * 2;
                const radius = 5 + progress * 15;
                const dropX = x + Math.cos(angle) * radius;
                const dropY = y + Math.sin(angle) * radius;
                
                ctx.fillStyle = `rgba(100, 181, 246, ${1 - progress})`;
                ctx.beginPath();
                ctx.arc(dropX, dropY, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawAnimations(timestamp) { 
            activeAnimations = activeAnimations.filter(anim => {
                const elapsed = timestamp - anim.startTime;
                if (elapsed > anim.duration) return false;
                
                if (anim.type === 'water') {
                    drawWaterAnimation(anim, timestamp);
                }
                return true;
            });
        }
        
        function drawPlantTimers(timestamp) { 
            ctx.font = 'bold 12px Consolas';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 2;

            for (const key in plantGrowthData) {
                const [x, y] = key.split(',').map(Number);
                const data = plantGrowthData[key];
                const tileId = map[y][x];

                if (tileId >= 4 && tileId <= 6) { 
                    
                    const timePassed = timestamp - data.plantedAt;
                    const effectiveAge = timePassed; 
                    
                    let targetTime = 0;
                    if (tileId === 4) targetTime = GROWTH_TIME_SPROUT;
                    else if (tileId === 5) targetTime = GROWTH_TIME_PLANT;
                    else if (tileId === 6) targetTime = GROWTH_TIME_HARVEST;

                    if (data.boosted) {
                        targetTime = targetTime * 0.5; 
                    }

                    const timeLeft = Math.max(0, targetTime - effectiveAge);
                    const secondsLeft = Math.ceil(timeLeft / 1000);

                    const drawX = x * TILE_SIZE + (TILE_SIZE / 2);
                    const drawY = y * TILE_SIZE - 5; 

                    ctx.fillStyle = 'white';
                    ctx.fillText(`${secondsLeft}s`, drawX, drawY);
                }
            }
            ctx.shadowBlur = 0; 
        }
        
        function updateGameTime() {
            const now = new Date();
            const realMinutesInHour = now.getMinutes();
            const realSecondsInHour = now.getSeconds();
            const totalRealSecondsInHour = (realMinutesInHour * 60) + realSecondsInHour;
            const progress = totalRealSecondsInHour / REAL_SECONDS_PER_GAME_DAY;
            let totalGameMinutes = Math.floor(GAME_MINUTES_PER_DAY * progress);
            const offsetMinutes = gameTimeOffset * 60;
            totalGameMinutes = (totalGameMinutes + offsetMinutes) % GAME_MINUTES_PER_DAY;
            gameHour = Math.floor(totalGameMinutes / 60);
            gameMinute = totalGameMinutes % 60;
        }

        function updateNightOverlay() {
            if (!nightOverlay) return;
            const maxOpacity = 0.7; // Escuridão máxima
            let targetOpacity = 0;

            if (gameHour >= 20 || gameHour < 4) targetOpacity = maxOpacity; // Noite total
            else if (gameHour === 4) targetOpacity = maxOpacity * 0.66; // Amanhecer 1
            else if (gameHour === 5) targetOpacity = maxOpacity * 0.33; // Amanhecer 2
            else if (gameHour >= 6 && gameHour < 18) targetOpacity = 0; // Dia
            else if (gameHour === 18) targetOpacity = maxOpacity * 0.33; // Entardecer 1
            else if (gameHour === 19) targetOpacity = maxOpacity * 0.66; // Entardecer 2
            
            nightOverlay.style.opacity = targetOpacity;

            drawLighting(lastTime);
        }

        function drawTimeIcon() {
            timeIconCtx.clearRect(0, 0, timeIconCanvas.width, timeIconCanvas.height);
            const centerX = timeIconCanvas.width / 2;
            const centerY = timeIconCanvas.height / 2;
            const radius = 8;

            if (gameHour >= 6 && gameHour < 18) { // Dia
                timeIconCtx.fillStyle = '#FFD700'; 
                timeIconCtx.beginPath();
                timeIconCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                timeIconCtx.fill();
            } else { // Noite
                timeIconCtx.fillStyle = '#A0A0A0'; 
                timeIconCtx.beginPath();
                timeIconCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                timeIconCtx.fill();
                timeIconCtx.fillStyle = 'rgba(0,0,0,0)'; 
                timeIconCtx.globalCompositeOperation = 'destination-out'; 
                timeIconCtx.beginPath();
                timeIconCtx.arc(centerX + radius * 0.4, centerY - radius * 0.4, radius, 0, Math.PI * 2);
                timeIconCtx.fill();
                timeIconCtx.globalCompositeOperation = 'source-over'; 
            }
        }

        function drawGameClock() {
            if (!gameClockSpan) return;
            const hourStr = String(gameHour).padStart(2, '0');
            const minStr = String(gameMinute).padStart(2, '0');
            gameClockSpan.textContent = `${hourStr}:${minStr}`;
            drawTimeIcon(); 
        }

        function drawLighting(timestamp) {
            lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
            
            if (gameHour >= 18 || gameHour < 6) { 
                lightCtx.save();
                
                const currentNightOpacity = nightOverlay ? parseFloat(nightOverlay.style.opacity) : 0;
                lightCtx.fillStyle = `rgba(0, 0, 30, ${currentNightOpacity * 0.9})`; 
                lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

                lightCtx.globalCompositeOperation = 'destination-out';

                for (const obj of mapObjects) {
                    const x_on_screen = obj.x * TILE_SIZE - camera.x;
                    const y_on_screen = obj.y * TILE_SIZE - camera.y;

                    let lightRadius = 0;
                    let lightX = x_on_screen + TILE_SIZE / 2;
                    let lightY = y_on_screen + TILE_SIZE / 2;

                    if (obj.type === 2) { // Fogueira
                        lightRadius = 3.5 * TILE_SIZE; 
                    } else if (obj.type === 3) { // Tocha
                        lightRadius = 2.5 * TILE_SIZE; 
                        lightY = y_on_screen + TILE_SIZE * 0.75; 
                    }

                    if (lightRadius > 0) {
                        if (lightX + lightRadius > 0 && lightX - lightRadius < lightCanvas.width &&
                            lightY + lightRadius > 0 && lightY - lightRadius < lightCanvas.height)
                        {
                            const pulse = Math.sin(timestamp * 0.005) * 0.05 + 0.95; 
                            const gradient = lightCtx.createRadialGradient(
                                lightX, lightY, 0,
                                lightX, lightY, lightRadius * pulse
                            );
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
                            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)');
                            gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.5)');
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); 

                            lightCtx.fillStyle = gradient;
                            lightCtx.beginPath();
                            lightCtx.arc(lightX, lightY, lightRadius * pulse, 0, Math.PI * 2);
                            lightCtx.fill();
                        }
                    }
                }
                lightCtx.globalCompositeOperation = 'source-over';
                // lightCtx.restore(); // Removido pois save não era necessário sem o translate/scale
            }
        }


        // --- Loop Principal (Update e Draw) ---
        function updatePlayerMovement(timestamp) { 
            if (player.isMoving) {
                let dx = player.targetX - player.x;
                let dy = player.targetY - player.y;

                if (Math.abs(dx) < player.speed) player.x = player.targetX;
                else player.x += Math.sign(dx) * player.speed;

                if (Math.abs(dy) < player.speed) player.y = player.targetY;
                else player.y += Math.sign(dy) * player.speed;
                
                player.walkBob += player.walkBobSpeed;

                if (player.x === player.targetX && player.y === player.targetY) {
                    player.isMoving = false;
                    player.walkBob = 0;
                }
            }
        }

        function updateToolAnimation(timestamp) { 
            if (player.isUsingTool) {
                if (timestamp - player.toolAnimStart > TOOL_ANIM_DURATION) {
                    player.isUsingTool = false;
                    useTool(timestamp);
                }
            }
        }
        
        function updateAnimations(timestamp) { 
             // Lógica movida para drawAnimations
        }

        function updateCamera() {
            // Ajusta para manter o jogador centralizado na tela real (640x480)
            const targetCamX = player.x - (640 / 2) + (player.width / 2);
            const targetCamY = player.y - (480 / 2) + (player.height / 2);

            // Prende a câmera nos limites do mapa, considerando o tamanho do canvas de renderização
            camera.x = Math.max(0, Math.min(targetCamX, MAP_WIDTH_PX - canvas.width));
            camera.y = Math.max(0, Math.min(targetCamY, MAP_HEIGHT_PX - canvas.height));
        }


        function update(timestamp) { 
            updatePlayerMovement(timestamp);
            updateToolAnimation(timestamp);
            updateAnimations(timestamp);
            updateCamera();
        }

        // --- ATUALIZADO: Função de Desenho com Y-Sorting ---
        function draw(timestamp) { 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.scale(zoomLevel, zoomLevel); // Aplica zoom se necessário (atualmente 1)
            ctx.translate(-camera.x, -camera.y);

            // 1. Desenha o Chão (Mapa pré-renderizado)
            ctx.drawImage(preRenderedMapCanvas, 0, 0);
            
            // 2. Coleta todos os objetos "desenháveis" (Jogador, Árvores, Pedras, Fogueiras, Tochas)
            let drawables = [];
            
            // Adiciona o Jogador
            drawables.push({
                type: 'player',
                x_px: player.x,
                y_px: player.y,
                y_sort: player.y + player.height - 4, // "Pés" do jogador
                draw: (ts) => drawPlayer(ts)
            });
            
            // Adiciona Sombra do Jogador (para ficar embaixo dele)
            drawables.push({
                type: 'shadow',
                x_px: player.x,
                y_px: player.y,
                y_sort: player.y + player.height - 5, // Logo atrás dos pés
                draw: () => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(player.x + player.width / 2, player.y + player.height + 2, player.width / 2.5, 4, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // Adiciona Objetos do Mapa (Árvores e Pedras, Fogueiras, Tochas)
            for (const obj of mapObjects) {
                const x_px = obj.x * TILE_SIZE;
                const y_px = obj.y * TILE_SIZE;
                const y_base = y_px + TILE_SIZE; // "Pés" do objeto (base do tile)

                if (obj.type === 0) { // Rocha
                     // Adiciona a sombra da rocha antes da rocha
                     drawables.push({
                        type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base - 1, 
                        draw: () => {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.beginPath();
                            ctx.ellipse(x_px + 16, y_base, 12, 6, 0, 0, 2 * Math.PI); ctx.fill();
                        }
                    });
                    drawables.push({
                        type: 'rock', x_px: x_px, y_px: y_px, y_sort: y_base,
                        draw: () => drawRock(ctx, x_px, y_px)
                    });
                } else if (obj.type === 1) { // Árvore (dividida em tronco e copa)
                     // Adiciona a sombra da copa antes da copa
                     drawables.push({
                        type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base -1, // Sombra abaixo da base
                        draw: () => {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.beginPath();
                            ctx.ellipse(x_px + TILE_SIZE/2, y_base, TILE_SIZE * 0.75, TILE_SIZE * 0.4, 0, 0, 2 * Math.PI); ctx.fill();
                        }
                    });
                    // Tronco
                    drawables.push({
                        type: 'tree_trunk', x_px: x_px, y_px: y_px, y_sort: y_base,
                        draw: () => drawTreeTrunk(ctx, x_px, y_px)
                    });
                    // Copa (desenhada *acima* de outros objetos)
                    drawables.push({
                        type: 'tree_canopy', x_px: x_px, y_px: y_px, y_sort: y_base + TILE_SIZE * 2, // Garante que a copa sempre apareça por cima de tudo
                        draw: () => drawTreeCanopy(ctx, x_px, y_px)
                    });
                } else if (obj.type === 2) { // Fogueira
                     // Adiciona a sombra da fogueira
                     drawables.push({
                        type: 'shadow', x_px: x_px, y_px: y_px, y_sort: y_base - 1, 
                        draw: () => {
                             ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.beginPath();
                             ctx.ellipse(x_px + 16, y_base, 10, 5, 0, 0, 2 * Math.PI); ctx.fill();
                        }
                    });
                    drawables.push({
                        type: 'campfire', x_px: x_px, y_px: y_px, y_sort: y_base,
                        draw: (ts) => drawCampfire(ctx, x_px, y_px, ts)
                    });
                } else if (obj.type === 3) { // Tocha
                    drawables.push({
                        type: 'torch', x_px: x_px, y_px: y_px, y_sort: y_base, // Tochas podem ser "passadas por trás"
                        draw: (ts) => drawTorch(ctx, x_px, y_px, ts)
                    });
                }
            }
            
            // 3. Ordena os "desenháveis" pela posição Y (Y-Sorting)
            drawables.sort((a, b) => a.y_sort - b.y_sort);
            
            // 4. Desenha tudo na ordem correta
            for (const item of drawables) {
                item.draw(timestamp);
            }
            
            // 5. Desenha Animações e Timers (sempre por cima de tudo)
            drawAnimations(timestamp); 
            drawPlantTimers(timestamp); 
            
            ctx.restore();
        }
        
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            lastTime = timestamp;

            update(timestamp); 
            draw(timestamp);   
            drawLighting(timestamp); 
            
            requestAnimationFrame(gameLoop);
        }

        // --- Lógica do Jogo ---
        document.addEventListener('keydown', (e) => {
            if (player.isMoving || player.isUsingTool) return; 
            
            if (e.key >= '1' && e.key <= '7') {
                e.preventDefault();
                updateActiveSlot(parseInt(e.key, 10) - 1);
                return;
            }
            
            if (e.key === ' ') {
                e.preventDefault();
                player.isMoving = false;
                player.isUsingTool = true;
                player.toolAnimStart = lastTime; 
                return;
            }

            let newDir = null;
            switch (e.key) {
                case 'ArrowUp': newDir = { dx: 0, dy: -1 }; break;
                case 'ArrowDown': newDir = { dx: 0, dy: 1 }; break;
                case 'ArrowLeft': newDir = { dx: -1, dy: 0 }; break;
                case 'ArrowRight': newDir = { dx: 1, dy: 0 }; break;
            }
            if (!newDir) return;

            const isAlreadyFacing = (player.lastMoveDir.dx === newDir.dx && player.lastMoveDir.dy === newDir.dy);

            if (!isAlreadyFacing) {
                player.lastMoveDir = newDir; 
                return;
            }
            
            const targetX = player.targetX + newDir.dx * TILE_SIZE;
            const targetY = player.targetY + newDir.dy * TILE_SIZE;
            if (isWalkable(targetX, targetY)) {
                player.isMoving = true;
                player.targetX = targetX;
                player.targetY = targetY;
            }
        });

        // ATUALIZADO: Checagem de colisão com objetos
        function isWalkable(pixelX, pixelY) {
            const tileX = Math.floor(pixelX / TILE_SIZE);
            const tileY = Math.floor(pixelY / TILE_SIZE);

            // 1. Limites do Mapa
            if (tileX < 0 || tileX >= MAP_WIDTH_TILES || tileY < 0 || tileY >= MAP_HEIGHT_TILES) {
                return false;
            }
            
            // 2. Chão (Água)
            const tileId = map[tileY][tileX];
            if (tileId === 3) return false;
            
            // 3. Objetos (Árvores e Pedras, Fogueiras, Tochas)
            for (const obj of mapObjects) {
                // Tochas podem ser passadas por cima, fogueiras não.
                if ((obj.type === 0 || obj.type === 1 || obj.type === 2) && obj.x === tileX && obj.y === tileY) {
                    return false; // Não pode andar sobre rochas, troncos ou fogueiras
                }
            }
            
            return true;
        }

        // ATUALIZADO: Lógica da ferramenta para evitar objetos (incluindo fogueiras e tochas)
        function useTool(timestamp) { 
            const pTileX = Math.floor(player.x / TILE_SIZE);
            const pTileY = Math.floor(player.y / TILE_SIZE);
            const targetTileX = pTileX + player.lastMoveDir.dx;
            const targetTileY = pTileY + player.lastMoveDir.dy;

            if (targetTileX < 0 || targetTileX >= MAP_WIDTH_TILES || targetTileY < 0 || targetTileY >= MAP_HEIGHT_TILES) {
                return;
            }
            
            // Checa se há um objeto (pedra/árvore/fogueira/tocha) no local
            for (const obj of mapObjects) {
                // Ferramentas não afetam objetos estáticos
                if ((obj.type === 0 || obj.type === 1 || obj.type === 2 || obj.type === 3) && obj.x === targetTileX && obj.y === targetTileY) {
                    return; 
                }
            }
            
            const targetKey = `${targetTileX},${targetTileY}`;
            const tileId = map[targetTileY][targetTileX];
            const item = inventory[activeSlot];

            if (!item) return;

            // 1. Lógica de Colheita
            if (tileId === 7) {
                map[targetTileY][targetTileX] = 2;
                delete plantGrowthData[targetKey];
                inventory[2].count++;
                updatePreRenderedTile(targetTileX, targetTileY, 2);
                saveGame();
                updateInventoryUI();
                return;
            }

            // 2. Lógica de Ferramenta
            switch(item.name) {
                case "Enxada":
                    if (tileId === 0 || tileId === 1) {
                        map[targetTileY][targetTileX] = 2;
                        updatePreRenderedTile(targetTileX, targetTileY, 2);
                        saveGame();
                    }
                    break;
                case "Semente":
                    if (tileId === 2 && item.count > 0) {
                        map[targetTileY][targetTileX] = 4;
                        plantGrowthData[targetKey] = { plantedAt: timestamp, boosted: false };
                        item.count--;
                        updatePreRenderedTile(targetTileX, targetTileY, 4);
                        saveGame();
                        updateInventoryUI();
                    }
                    break;
                case "Pá":
                    if (tileId === 1 || tileId === 2) {
                        map[targetTileY][targetTileX] = 0;
                        if (plantGrowthData[targetKey]) {
                            delete plantGrowthData[targetKey];
                        }
                        updatePreRenderedTile(targetTileX, targetTileY, 0);
                        saveGame();
                    } else if (tileId === 0) {
                        let adjacentWater = false;
                        const neighbors = [[0,1], [0,-1], [1,0], [-1,0]];
                        for (const [nx, ny] of neighbors) {
                            const checkX = targetTileX + nx;
                            const checkY = targetTileY + ny;
                            if (checkX >= 0 && checkX < MAP_WIDTH_TILES && checkY >= 0 && checkY < MAP_HEIGHT_TILES) {
                                if (map[checkY][checkX] === 3) {
                                    adjacentWater = true;
                                    break;
                                }
                            }
                        }
                        if (adjacentWater) {
                            map[targetTileY][targetTileX] = 3;
                            updatePreRenderedTile(targetTileX, targetTileY, 3);
                            saveGame();
                        }
                    }
                    break;
                case "Regador":
                    if (tileId === 3) {
                        item.count = 10;
                        updateInventoryUI();
                        saveGame();
                    } else if (tileId >= 4 && tileId <= 6 && item.count > 0) { // Usar na Planta
                        const plantData = plantGrowthData[targetKey];
                        if (plantData && !plantData.boosted) { // Só rega se não foi regada
                            plantData.boosted = true;
                            item.count--;
                            activeAnimations.push({ type: 'water', x: targetTileX, y: targetTileY, startTime: timestamp, duration: 500 });
                            updateInventoryUI();
                            saveGame();
                        }
                    }
                    break;
            }
        }
        
        function updatePlantGrowth(timestamp) { 
            let mapChanged = false;
            for (const key in plantGrowthData) {
                const [x, y] = key.split(',').map(Number);
                const data = plantGrowthData[key];
                
                const timePassed = timestamp - data.plantedAt;
                const effectiveAge = timePassed; 

                const currentTileId = map[y][x];
                
                const boostMultiplier = data.boosted ? 0.5 : 1;
                
                const targetSprout = GROWTH_TIME_SPROUT * boostMultiplier;
                const targetPlant = GROWTH_TIME_PLANT * boostMultiplier;
                const targetHarvest = GROWTH_TIME_HARVEST * boostMultiplier;


                let newTileId = -1;
                if (effectiveAge > targetHarvest && currentTileId === 6) newTileId = 7;
                else if (effectiveAge > targetPlant && currentTileId === 5) newTileId = 6;
                else if (effectiveAge > targetSprout && currentTileId === 4) newTileId = 5;
                
                if (newTileId !== -1) {
                    map[y][x] = newTileId;
                    updatePreRenderedTile(x, y, newTileId);
                    mapChanged = true;
                }
            }
            if (mapChanged) {
                saveGame();
            }
        }
        
        function startGrowthTimer() {
            setInterval(() => {
                updatePlantGrowth(lastTime);
            }, 1000);
        }

        // --- Funções de UI (Inventário de Texto) ---
        function updateInventoryUI() {
            const slots = document.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                const item = inventory[index];
                const nameSpan = slot.querySelector('.slot-name');
                const countSpan = slot.querySelector('.slot-count');

                if (item) {
                    nameSpan.textContent = item.name;
                    if (item.name === "Enxada" || item.name === "Pá") {
                         countSpan.textContent = "";
                    } else {
                         countSpan.textContent = item.count;
                    }
                } else {
                    nameSpan.textContent = "";
                    countSpan.textContent = "";
                }

                if (index === activeSlot) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            });
        }

        function updateActiveSlot(slotIndex) {
            activeSlot = slotIndex;
            saveGame();
            updateInventoryUI();
        }

        // --- ATUALIZADO: Persistência (Salvar/Carregar) ---
        function saveGame() {
            try {
                const saveData = {
                    map: map,
                    plantData: plantGrowthData,
                    mapObjects: mapObjects, 
                    inventoryData: inventory.map(item => item ? { name: item.name, count: item.count } : null), 
                    activeSlotData: activeSlot
                };
                localStorage.setItem('pixelFarmSaveData', JSON.stringify(saveData));
            } catch (e) {
                console.error("Erro ao salvar o jogo:", e);
            }
        }

        function loadGame() {
            const savedData = localStorage.getItem('pixelFarmSaveData');
            
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    
                    if (data.map) map = data.map;
                    if (data.activeSlotData) activeSlot = data.activeSlotData;
                    if (data.mapObjects) mapObjects = data.mapObjects; 
                    
                    if (data.plantData) {
                        for (const key in data.plantData) {
                            const plant = data.plantData[key];
                            // Migra saves antigos
                            if (typeof plant.boost === 'number' && plant.boost > 0) {
                                plant.boosted = true;
                                delete plant.boost; 
                            } else if (typeof plant.boosted === 'undefined') {
                                plant.boosted = false; 
                            }
                        }
                        plantGrowthData = data.plantData;
                    }

                    if (data.inventoryData) {
                        let loadedInv = data.inventoryData;
                        for(let i = 0; i < inventory.length; i++) {
                            // Carrega contagens apenas para itens que existem no inventário padrão
                            if(loadedInv[i] && inventory[i] && typeof loadedInv[i].count === 'number') {
                                 inventory[i].count = loadedInv[i].count;
                            }
                        }
                    }
                    console.log("Jogo carregado.");
                } catch (e) {
                    console.error("Erro ao carregar o save, usando dados padrão.", e);
                }
            } else {
                console.log("Nenhum save encontrado, iniciando novo jogo.");
            }
        }

        // --- Inicialização ---
        function init() {
            loadGame();
            preRenderMap(); 
            updateInventoryUI();
            startGrowthTimer();

            // Loop do Relógio
            updateGameTime();
            drawGameClock();
            updateNightOverlay(); 
            setInterval(() => {
                updateGameTime();
                drawGameClock();
                updateNightOverlay(); 
            }, 1000); 

            // Listener de clique do inventário
            document.querySelectorAll('.slot').forEach(slotElement => {
                slotElement.addEventListener('click', (e) => {
                    const index = parseInt(e.currentTarget.dataset.index, 10);
                    if (!isNaN(index)) {
                        updateActiveSlot(index);
                    }
                });
            });

            // Listener do Botão de Teste
            document.getElementById('timeToggleButton').addEventListener('click', () => {
                gameTimeOffset = (gameTimeOffset + 12) % 24;
                updateGameTime();
                drawGameClock(); 
                updateNightOverlay();
                console.log("Tempo avançado em 12h. Offset atual: " + gameTimeOffset);
            });
            
            requestAnimationFrame(gameLoop);
        }

        init();

    </script>
</body>
</html>

